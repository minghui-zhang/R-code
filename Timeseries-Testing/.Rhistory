summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2, na.rm = FALSE)
t <- ts_R$t
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, t, dEVI)
ts_R$dEVI_smoothed <- dEVI_smoothed
# numerically find date of maxEVI and max dEVI (after smoothing)
maxEVIday <- ts_R$t[which(ts_R$EVI_smoothed2 == max(ts_R$EVI_smoothed2, na.rm = TRUE))][1]
maxdEVIday <- ts_R$t[which(ts_R$dEVI_smoothed == max(ts_R$dEVI_smoothed, na.rm = TRUE))][1]
quarterPd <- maxEVIday - maxdEVIday
# get window over which to fit
windowStart <- maxEVIday - 2*quarterPd
windowEnd <- maxEVIday + quarterPd
ts_fitting_R <- ts_R[which(ts_R$t >= windowStart & ts_R$t <= windowEnd),]
freq_invYrs <- 1/(4*(quarterPd/365)) # omega
# fit over first crop. benchmark to Aug 1
t_yrs <- (ts_fitting_R$t)/365
wt <- 2*3.14*freq_invYrs*t_yrs
EVI_fitting <- ts_fitting_R$EVI_smoothed2
# Model that sets w (as in TIMESAT)
model_GEE_harmonic <- lm(EVI_fitting~ t_yrs + cos(wt) + sin(wt))
plot(ts_fitting_R$t, EVI_fitting)
lines(ts_fitting_R$t, EVI_fitting, col = "green")
lines(ts_fitting_R$t, fitted(model_GEE_harmonic), col = "red")
length(fitted(model_GEE_harmonic))
length(t)
View(ts_fitting_R)
length(ts_fitting_R$t)
length(EVI_fitting)
# function to smooth by certain number of days (not by index). numDays creates +/- window; so actual smoothing window is - numDays to + numDays
smooth_by_days <- function(numDays, t, values) {
smoothed <- numeric(length(values))
for (index in 1:length(values)) {
# get time window
day_center <- t[index]
day_start <- day_center - numDays
day_end <- day_center + numDays
# get indices corresponding to time window
indices <- which(t >= day_start & t <= day_end)
# get average of values over the indices and save
mean_value <- mean(values[indices], na.rm = TRUE)
smoothed[index] <- mean_value
}
return(smoothed)
}
# calculate first derivative of smoothed EVI (forward 1st order difference)
calc_1st_deriv <- function(values) {
derivatives <- numeric(length(values))
for (index in 1:(length(values)-1)) {
derivative <- values[index + 1] - values[index]
derivatives[index] <- derivative
}
derivatives[length(values)] <- derivatives[length(values) - 1] # to make sure the 1st derivative length still matches total time
return(derivatives)
}
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 0
window_EVI_2 <- 0
window_dEVI <- 0
numMissingPts <- 10
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2, na.rm = FALSE)
t <- ts_R$t
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, t, dEVI)
ts_R$dEVI_smoothed <- dEVI_smoothed
# numerically find date of maxEVI and max dEVI (after smoothing)
maxEVIday <- ts_R$t[which(ts_R$EVI_smoothed2 == max(ts_R$EVI_smoothed2, na.rm = TRUE))][1]
maxdEVIday <- ts_R$t[which(ts_R$dEVI_smoothed == max(ts_R$dEVI_smoothed, na.rm = TRUE))][1]
quarterPd <- maxEVIday - maxdEVIday
# get window over which to fit
windowStart <- maxEVIday - 2*quarterPd
windowEnd <- maxEVIday + quarterPd
ts_fitting_R <- ts_R[which(ts_R$t >= windowStart & ts_R$t <= windowEnd),]
freq_invYrs <- 1/(4*(quarterPd/365)) # omega
# fit over first crop. benchmark to Aug 1
t_yrs <- (ts_fitting_R$t)/365
wt <- 2*3.14*freq_invYrs*t_yrs
EVI_fitting <- ts_fitting_R$EVI_smoothed2
# Model that sets w (as in TIMESAT)
model_GEE_harmonic <- lm(EVI_fitting~ t_yrs + cos(wt) + sin(wt))
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 0
window_EVI_2 <- 0
window_dEVI <- 0
numMissingPts <- 4
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2, na.rm = FALSE)
t <- ts_R$t
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, t, dEVI)
ts_R$dEVI_smoothed <- dEVI_smoothed
# numerically find date of maxEVI and max dEVI (after smoothing)
maxEVIday <- ts_R$t[which(ts_R$EVI_smoothed2 == max(ts_R$EVI_smoothed2, na.rm = TRUE))][1]
maxdEVIday <- ts_R$t[which(ts_R$dEVI_smoothed == max(ts_R$dEVI_smoothed, na.rm = TRUE))][1]
quarterPd <- maxEVIday - maxdEVIday
# get window over which to fit
windowStart <- maxEVIday - 2*quarterPd
windowEnd <- maxEVIday + quarterPd
ts_fitting_R <- ts_R[which(ts_R$t >= windowStart & ts_R$t <= windowEnd),]
freq_invYrs <- 1/(4*(quarterPd/365)) # omega
# fit over first crop. benchmark to Aug 1
t_yrs <- (ts_fitting_R$t)/365
wt <- 2*3.14*freq_invYrs*t_yrs
EVI_fitting <- ts_fitting_R$EVI_smoothed2
# Model that sets w (as in TIMESAT)
model_GEE_harmonic <- lm(EVI_fitting~ t_yrs + cos(wt) + sin(wt))
plot(ts_fitting_R$t, EVI_fitting)
lines(ts_fitting_R$t, EVI_fitting, col = "green")
lines(ts_fitting_R$t, fitted(model_GEE_harmonic), col = "red")
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 0
window_EVI_2 <- 0
window_dEVI <- 0
numMissingPts <- 4
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2, na.rm = FALSE)
t <- ts_R$t
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, t, dEVI)
ts_R$dEVI_smoothed <- dEVI_smoothed
# numerically find date of maxEVI and max dEVI (after smoothing)
maxEVIday <- ts_R$t[which(ts_R$EVI_smoothed2 == max(ts_R$EVI_smoothed2, na.rm = TRUE))][1]
maxdEVIday <- ts_R$t[which(ts_R$dEVI_smoothed == max(ts_R$dEVI_smoothed, na.rm = TRUE))][1]
quarterPd <- maxEVIday - maxdEVIday
# get window over which to fit
windowStart <- maxEVIday - 2*quarterPd
windowEnd <- maxEVIday + quarterPd
ts_fitting_R <- ts_R[which(ts_R$t >= windowStart & ts_R$t <= windowEnd),]
freq_invYrs <- 1/(4*(quarterPd/365)) # omega
# fit over first crop. benchmark to Aug 1
t_yrs <- (ts_fitting_R$t)/365
wt <- 2*3.14*freq_invYrs*t_yrs
EVI_fitting <- ts_fitting_R$EVI_smoothed2
# Model that sets w (as in TIMESAT)
model_GEE_harmonic <- lm(EVI_fitting~ t_yrs + cos(wt) + sin(wt))
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 0
window_EVI_2 <- 0
window_dEVI <- 0
numMissingPts <- 4
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2, na.rm = FALSE)
t <- ts_R$t
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, t, dEVI)
ts_R$dEVI_smoothed <- dEVI_smoothed
# numerically find date of maxEVI and max dEVI (after smoothing)
maxEVIday <- ts_R$t[which(ts_R$EVI_smoothed2 == max(ts_R$EVI_smoothed2, na.rm = TRUE))][1]
maxdEVIday <- ts_R$t[which(ts_R$dEVI_smoothed == max(ts_R$dEVI_smoothed, na.rm = TRUE))][1]
quarterPd <- maxEVIday - maxdEVIday
# get window over which to fit
windowStart <- maxEVIday - 2*quarterPd
windowEnd <- maxEVIday + quarterPd
ts_fitting_R <- ts_R[which(ts_R$t >= windowStart & ts_R$t <= windowEnd),]
freq_invYrs <- 1/(4*(quarterPd/365)) # omega
# fit over first crop. benchmark to Aug 1
t_yrs <- (ts_fitting_R$t)/365
wt <- 2*3.14*freq_invYrs*t_yrs
EVI_fitting <- ts_fitting_R$EVI_smoothed2
# Model that sets w (as in TIMESAT)
model_GEE_harmonic <- lm(EVI_fitting~ t_yrs + cos(wt) + sin(wt))
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 0
window_EVI_2 <- 0
window_dEVI <- 0
numMissingPts <- 4
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2, na.rm = FALSE)
t <- ts_R$t
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, t, dEVI)
ts_R$dEVI_smoothed <- dEVI_smoothed
# numerically find date of maxEVI and max dEVI (after smoothing)
maxEVIday <- ts_R$t[which(ts_R$EVI_smoothed2 == max(ts_R$EVI_smoothed2, na.rm = TRUE))][1]
maxdEVIday <- ts_R$t[which(ts_R$dEVI_smoothed == max(ts_R$dEVI_smoothed, na.rm = TRUE))][1]
quarterPd <- maxEVIday - maxdEVIday
# get window over which to fit
windowStart <- maxEVIday - 2*quarterPd
windowEnd <- maxEVIday + quarterPd
ts_fitting_R <- ts_R[which(ts_R$t >= windowStart & ts_R$t <= windowEnd),]
freq_invYrs <- 1/(4*(quarterPd/365)) # omega
# fit over first crop. benchmark to Aug 1
t_yrs <- (ts_fitting_R$t)/365
wt <- 2*3.14*freq_invYrs*t_yrs
EVI_fitting <- ts_fitting_R$EVI_smoothed2
# Model that sets w (as in TIMESAT)
model_GEE_harmonic <- lm(EVI_fitting~ t_yrs + cos(wt) + sin(wt))
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 0
window_EVI_2 <- 0
window_dEVI <- 0
numMissingPts <- 4
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2, na.rm = FALSE)
t <- ts_R$t
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, t, dEVI)
ts_R$dEVI_smoothed <- dEVI_smoothed
# numerically find date of maxEVI and max dEVI (after smoothing)
maxEVIday <- ts_R$t[which(ts_R$EVI_smoothed2 == max(ts_R$EVI_smoothed2, na.rm = TRUE))][1]
maxdEVIday <- ts_R$t[which(ts_R$dEVI_smoothed == max(ts_R$dEVI_smoothed, na.rm = TRUE))][1]
quarterPd <- maxEVIday - maxdEVIday
# get window over which to fit
windowStart <- maxEVIday - 2*quarterPd
windowEnd <- maxEVIday + quarterPd
ts_fitting_R <- ts_R[which(ts_R$t >= windowStart & ts_R$t <= windowEnd),]
freq_invYrs <- 1/(4*(quarterPd/365)) # omega
# fit over first crop. benchmark to Aug 1
t_yrs <- (ts_fitting_R$t)/365
wt <- 2*3.14*freq_invYrs*t_yrs
EVI_fitting <- ts_fitting_R$EVI_smoothed2
# Model that sets w (as in TIMESAT)
model_GEE_harmonic <- lm(EVI_fitting~ t_yrs + cos(wt) + sin(wt))
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 0
window_EVI_2 <- 0
window_dEVI <- 0
numMissingPts <- 4
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2, na.rm = FALSE)
t <- ts_R$t
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, t, dEVI)
ts_R$dEVI_smoothed <- dEVI_smoothed
# numerically find date of maxEVI and max dEVI (after smoothing)
maxEVIday <- ts_R$t[which(ts_R$EVI_smoothed2 == max(ts_R$EVI_smoothed2, na.rm = TRUE))][1]
maxdEVIday <- ts_R$t[which(ts_R$dEVI_smoothed == max(ts_R$dEVI_smoothed, na.rm = TRUE))][1]
quarterPd <- maxEVIday - maxdEVIday
# get window over which to fit
windowStart <- maxEVIday - 2*quarterPd
windowEnd <- maxEVIday + quarterPd
ts_fitting_R <- ts_R[which(ts_R$t >= windowStart & ts_R$t <= windowEnd),]
freq_invYrs <- 1/(4*(quarterPd/365)) # omega
# fit over first crop. benchmark to Aug 1
t_yrs <- (ts_fitting_R$t)/365
wt <- 2*3.14*freq_invYrs*t_yrs
EVI_fitting <- ts_fitting_R$EVI_smoothed2
# Model that sets w (as in TIMESAT)
model_GEE_harmonic <- lm(EVI_fitting~ t_yrs + cos(wt) + sin(wt))
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 0
window_EVI_2 <- 0
window_dEVI <- 0
numMissingPts <- 4
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2, na.rm = FALSE)
t <- ts_R$t
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, t, dEVI)
ts_R$dEVI_smoothed <- dEVI_smoothed
# numerically find date of maxEVI and max dEVI (after smoothing)
maxEVIday <- ts_R$t[which(ts_R$EVI_smoothed2 == max(ts_R$EVI_smoothed2, na.rm = TRUE))][1]
maxdEVIday <- ts_R$t[which(ts_R$dEVI_smoothed == max(ts_R$dEVI_smoothed, na.rm = TRUE))][1]
quarterPd <- maxEVIday - maxdEVIday
# get window over which to fit
windowStart <- maxEVIday - 2*quarterPd
windowEnd <- maxEVIday + quarterPd
ts_fitting_R <- ts_R[which(ts_R$t >= windowStart & ts_R$t <= windowEnd),]
freq_invYrs <- 1/(4*(quarterPd/365)) # omega
# fit over first crop. benchmark to Aug 1
t_yrs <- (ts_fitting_R$t)/365
wt <- 2*3.14*freq_invYrs*t_yrs
EVI_fitting <- ts_fitting_R$EVI_smoothed2
# Model that sets w (as in TIMESAT)
model_GEE_harmonic <- lm(EVI_fitting~ t_yrs + cos(wt) + sin(wt))
plot(ts_fitting_R$t, EVI_fitting)
lines(ts_fitting_R$t, EVI_fitting, col = "green")
lines(ts_fitting_R$t, predict(model_GEE_harmonic), col = "red")

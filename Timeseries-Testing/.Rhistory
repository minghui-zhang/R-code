library(dplyr)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 10
window_EVI_2 <- 10
window_dEVI <- 10
numMissingPts <- 9
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
print('length EVI_smoothed1')
print(length(EVI_smoothed1))
print('length EVI_smoothed2')
print(length(EVI_smoothed2))
dEVI <- calc_1st_deriv(EVI_smoothed2)
dEVI <- dEVI[! which(dEVI == 0)]
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, unique(t), dEVI)
print('length dEVI')
print(length(dEVI))
print('length dEVI_smoothed')
print(length(dEVI_smoothed))
# save R-calculated timeseries
ts_R <- data.frame(t, dEVI = rep(dEVI, each = 2), dEVI_smoothed = rep(dEVI_smoothed, each = 2), EVI_smoothed1, EVI_smoothed2, EVI_raw)
EVI_smoothed2
EVI_raw
length(EVI_raw)
length(EVI_smoothed2)
EVI_smoothed1
EVI_smoothed2
t
length(t)
newdata <- data.frame(t, EVI_smoothed2)
View(newdata)
library(dplyr)
newdata %>% group_by(t)
newdata_grouped <- newdata %>% group_by(t)
newdata_grouped %>% summarise_at(EVI_smoothed2, funs(mean(.)))
newdata_grouped %>% summarise_at(vars(EVI_smoothed2), funs(mean(.)))
newdata_grouped %>% summarise_at(vars(EVI_smoothed2), mean)
newdata_summarized <- newdata_grouped %>% summarise_at(vars(EVI_smoothed2), mean)
View(newdata_summarized)
install.packages('zo')
install.packages('zoo')
library(zoo)
na.approx(c(0, 1, NaN, 4))
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 10
window_EVI_2 <- 10
window_dEVI <- 10
numMissingPts <- 9
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2)
t <- ts_R$t
print('length EVI_smoothed1')
print(length(EVI_smoothed1))
print('length EVI_smoothed2')
print(length(EVI_smoothed2))
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, t, dEVI)
ts_R$dEVI_smoothed <- dEVI_smoothed
print('length dEVI')
print(length(dEVI))
print('length dEVI_smoothed')
print(length(dEVI_smoothed))
# numerically find date of maxEVI and max dEVI (after smoothing)
maxEVIday <- ts_R$t[which(ts_R$EVI_smoothed2 == max(ts_R$EVI_smoothed2, na.rm = TRUE))][1]
maxdEVIday <- ts_R$t[which(ts_R$dEVI_smoothed == max(ts_R$dEVI_smoothed, na.rm = TRUE))][1]
quarterPd <- maxEVIday - maxdEVIday
# get window over which to fit
windowStart <- maxEVIday - 2*quarterPd
windowEnd <- maxEVIday + quarterPd
ts_fitting_R <- ts_R[which(ts_R$t >= windowStart & ts_R$t <= windowEnd),]
freq_invYrs <- 1/(4*(quarterPd/365)) # omega
# fit over first crop. benchmark to Aug 1
t_yrs <- (ts_fitting_R$t)/365
wt <- 2*3.14*freq_invYrs*t_yrs
EVI_fitting <- ts_fitting_R$EVI_smoothed2
# Model that sets w (as in TIMESAT)
model_GEE_harmonic <- lm(EVI_fitting~ t_yrs + cos(wt) + sin(wt))
plot(ts_fitting_R$t, EVI_fitting)
lines(ts_fitting_R$t, EVI_fitting, col = "green")
lines(ts_fitting_R$t, fitted(model_GEE_harmonic), col = "red")
# calculate fitted maximum day. NOTE, the fitted phi doesn't always match with GEE fitted phi... GEE's phi is usually around +2 or -3
b2 <- model_GEE_harmonic$coefficients[3]
b3 <- model_GEE_harmonic$coefficients[4]
phi <- (atan(b3/b2))
# the phase when calculated from the day the harmonic function started fitting (windowStart)
maxEVIday_fitted <- 365*phi/(2*3.14*freq_invYrs)
if (maxEVIday_fitted < 0) {maxEVIday_fitted <- maxEVIday_fitted + 365/freq_invYrs}
results <- c(maxEVIday, quarterPd, maxEVIday_fitted)
names(results) <- c('maxEVIday_numeric', 'quarterPd', 'maxEVIday_fitted')
#  return(results)
#}
#GEE_results <- R_GEE_algorithm(ts, 10, 10, 0, 0)
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 10
window_EVI_2 <- 10
window_dEVI <- 10
numMissingPts <- 2
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2)
t <- ts_R$t
print('length EVI_smoothed1')
print(length(EVI_smoothed1))
print('length EVI_smoothed2')
print(length(EVI_smoothed2))
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, t, dEVI)
ts_R$dEVI_smoothed <- dEVI_smoothed
print('length dEVI')
print(length(dEVI))
print('length dEVI_smoothed')
print(length(dEVI_smoothed))
# numerically find date of maxEVI and max dEVI (after smoothing)
maxEVIday <- ts_R$t[which(ts_R$EVI_smoothed2 == max(ts_R$EVI_smoothed2, na.rm = TRUE))][1]
maxdEVIday <- ts_R$t[which(ts_R$dEVI_smoothed == max(ts_R$dEVI_smoothed, na.rm = TRUE))][1]
quarterPd <- maxEVIday - maxdEVIday
# get window over which to fit
windowStart <- maxEVIday - 2*quarterPd
windowEnd <- maxEVIday + quarterPd
ts_fitting_R <- ts_R[which(ts_R$t >= windowStart & ts_R$t <= windowEnd),]
freq_invYrs <- 1/(4*(quarterPd/365)) # omega
# fit over first crop. benchmark to Aug 1
t_yrs <- (ts_fitting_R$t)/365
wt <- 2*3.14*freq_invYrs*t_yrs
EVI_fitting <- ts_fitting_R$EVI_smoothed2
# Model that sets w (as in TIMESAT)
model_GEE_harmonic <- lm(EVI_fitting~ t_yrs + cos(wt) + sin(wt))
plot(ts_fitting_R$t, EVI_fitting)
lines(ts_fitting_R$t, EVI_fitting, col = "green")
lines(ts_fitting_R$t, fitted(model_GEE_harmonic), col = "red")
# calculate fitted maximum day. NOTE, the fitted phi doesn't always match with GEE fitted phi... GEE's phi is usually around +2 or -3
b2 <- model_GEE_harmonic$coefficients[3]
b3 <- model_GEE_harmonic$coefficients[4]
phi <- (atan(b3/b2))
# the phase when calculated from the day the harmonic function started fitting (windowStart)
maxEVIday_fitted <- 365*phi/(2*3.14*freq_invYrs)
if (maxEVIday_fitted < 0) {maxEVIday_fitted <- maxEVIday_fitted + 365/freq_invYrs}
results <- c(maxEVIday, quarterPd, maxEVIday_fitted)
names(results) <- c('maxEVIday_numeric', 'quarterPd', 'maxEVIday_fitted')
#  return(results)
#}
#GEE_results <- R_GEE_algorithm(ts, 10, 10, 0, 0)
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 10
window_EVI_2 <- 10
window_dEVI <- 10
numMissingPts <- 4
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2)
t <- ts_R$t
print('length EVI_smoothed1')
print(length(EVI_smoothed1))
print('length EVI_smoothed2')
print(length(EVI_smoothed2))
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, t, dEVI)
ts_R$dEVI_smoothed <- dEVI_smoothed
print('length dEVI')
print(length(dEVI))
print('length dEVI_smoothed')
print(length(dEVI_smoothed))
# numerically find date of maxEVI and max dEVI (after smoothing)
maxEVIday <- ts_R$t[which(ts_R$EVI_smoothed2 == max(ts_R$EVI_smoothed2, na.rm = TRUE))][1]
maxdEVIday <- ts_R$t[which(ts_R$dEVI_smoothed == max(ts_R$dEVI_smoothed, na.rm = TRUE))][1]
quarterPd <- maxEVIday - maxdEVIday
# get window over which to fit
windowStart <- maxEVIday - 2*quarterPd
windowEnd <- maxEVIday + quarterPd
ts_fitting_R <- ts_R[which(ts_R$t >= windowStart & ts_R$t <= windowEnd),]
freq_invYrs <- 1/(4*(quarterPd/365)) # omega
# fit over first crop. benchmark to Aug 1
t_yrs <- (ts_fitting_R$t)/365
wt <- 2*3.14*freq_invYrs*t_yrs
EVI_fitting <- ts_fitting_R$EVI_smoothed2
# Model that sets w (as in TIMESAT)
model_GEE_harmonic <- lm(EVI_fitting~ t_yrs + cos(wt) + sin(wt))
plot(ts_fitting_R$t, EVI_fitting)
lines(ts_fitting_R$t, EVI_fitting, col = "green")
lines(ts_fitting_R$t, fitted(model_GEE_harmonic), col = "red")
# calculate fitted maximum day. NOTE, the fitted phi doesn't always match with GEE fitted phi... GEE's phi is usually around +2 or -3
b2 <- model_GEE_harmonic$coefficients[3]
b3 <- model_GEE_harmonic$coefficients[4]
phi <- (atan(b3/b2))
# the phase when calculated from the day the harmonic function started fitting (windowStart)
maxEVIday_fitted <- 365*phi/(2*3.14*freq_invYrs)
if (maxEVIday_fitted < 0) {maxEVIday_fitted <- maxEVIday_fitted + 365/freq_invYrs}
results <- c(maxEVIday, quarterPd, maxEVIday_fitted)
names(results) <- c('maxEVIday_numeric', 'quarterPd', 'maxEVIday_fitted')
#  return(results)
#}
#GEE_results <- R_GEE_algorithm(ts, 10, 10, 0, 0)
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 0
window_EVI_2 <- 0
window_dEVI <- 0
numMissingPts <- 0
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2)
t <- ts_R$t
print('length EVI_smoothed1')
print(length(EVI_smoothed1))
print('length EVI_smoothed2')
print(length(EVI_smoothed2))
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, t, dEVI)
ts_R$dEVI_smoothed <- dEVI_smoothed
print('length dEVI')
print(length(dEVI))
print('length dEVI_smoothed')
print(length(dEVI_smoothed))
# numerically find date of maxEVI and max dEVI (after smoothing)
maxEVIday <- ts_R$t[which(ts_R$EVI_smoothed2 == max(ts_R$EVI_smoothed2, na.rm = TRUE))][1]
maxdEVIday <- ts_R$t[which(ts_R$dEVI_smoothed == max(ts_R$dEVI_smoothed, na.rm = TRUE))][1]
quarterPd <- maxEVIday - maxdEVIday
# get window over which to fit
windowStart <- maxEVIday - 2*quarterPd
windowEnd <- maxEVIday + quarterPd
ts_fitting_R <- ts_R[which(ts_R$t >= windowStart & ts_R$t <= windowEnd),]
freq_invYrs <- 1/(4*(quarterPd/365)) # omega
# fit over first crop. benchmark to Aug 1
t_yrs <- (ts_fitting_R$t)/365
wt <- 2*3.14*freq_invYrs*t_yrs
EVI_fitting <- ts_fitting_R$EVI_smoothed2
# Model that sets w (as in TIMESAT)
model_GEE_harmonic <- lm(EVI_fitting~ t_yrs + cos(wt) + sin(wt))
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 0
window_EVI_2 <- 0
window_dEVI <- 0
numMissingPts <- 10
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2)
t <- ts_R$t
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
View(ts_R)
EVI_smoothed2
dEVI
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 0
window_EVI_2 <- 0
window_dEVI <- 0
numMissingPts <- 10
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2)
t <- ts_R$t
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
View(ts_R)
dEVI
na.approx(c(NaN, NaN, 1))
?na.approx
library(dplyr)
library(zoo)
# need to read in, because regardless of whether use smooth or unsmoothed EVI for the other fitting methods, must start with nonsmoothed EVI here. doubly smoothed EVI (20, 20) is in the csv
ts <- read.csv('point1.csv')[,1:2]
colnames(ts) <- c('date', 'EVI_raw')
ts$date <- as.Date(ts$date, '%d-%h-%y')
ts$day <- as.numeric(ts$date - as.Date('2016-08-01')) # number of days
# GEE algorithm function
# given: fitting degree (window size for smoothing EVI (2) and dEVI); timeseries as df, columns of date and raw EVI; number of points to take out randomly
# returns: quarter period and peak date
#R_GEE_algorithm <- function(ts, window_EVI_1, window_EVI_2, window_dEVI, numMissingPts) {
window_EVI_1 <- 0
window_EVI_2 <- 0
window_dEVI <- 0
numMissingPts <- 10
# cut EVI to only Aug 1, 2016 to April 1, 2017
ts <- ts[ts$day >= 0 & ts$day <= 243,]
# cut out randomly selected missing dates
missing_days <- sample(unique(ts$day), numMissingPts, replace = F) # days to take out
print('missing_days')
print(missing_days)
plot(ts$day, ts$EVI_raw, main = 'before and after taking out data')
ts$EVI_raw[ts$day %in% missing_days] <- NA # replace the randomly selected dates' EVI_raw with 'NA'
points(ts$day, ts$EVI_raw, col = 'red')
EVI_raw <- ts$EVI_raw
t <- ts$day
# smooth EVI series by 20 days, then 20 days
EVI_smoothed1 <- smooth_by_days(window_EVI_1, t, EVI_raw)
EVI_smoothed2 <- smooth_by_days(window_EVI_2, t, EVI_smoothed1)
# clean up EVI_smoothed2. for every date, replace with mean of the 2 EVI points and linearly interpolate at NaN times
ts_R <- data.frame(t, EVI_smoothed2)
ts_R <- ts_R %>% group_by(t) %>%
summarise_at(vars(EVI_smoothed2), mean)
# from here, the data won't be doubled on each date!
EVI_smoothed2 <- na.approx(ts_R$EVI_smoothed2, na.rm = FALSE)
t <- ts_R$t
dEVI <- calc_1st_deriv(EVI_smoothed2)
ts_R$dEVI <- dEVI
# calculate smoothed dEVI
dEVI_smoothed <- smooth_by_days(window_dEVI, t, dEVI)
ts_R$dEVI_smoothed <- dEVI_smoothed
# numerically find date of maxEVI and max dEVI (after smoothing)
maxEVIday <- ts_R$t[which(ts_R$EVI_smoothed2 == max(ts_R$EVI_smoothed2, na.rm = TRUE))][1]
maxdEVIday <- ts_R$t[which(ts_R$dEVI_smoothed == max(ts_R$dEVI_smoothed, na.rm = TRUE))][1]
quarterPd <- maxEVIday - maxdEVIday
# get window over which to fit
windowStart <- maxEVIday - 2*quarterPd
windowEnd <- maxEVIday + quarterPd
ts_fitting_R <- ts_R[which(ts_R$t >= windowStart & ts_R$t <= windowEnd),]
freq_invYrs <- 1/(4*(quarterPd/365)) # omega
# fit over first crop. benchmark to Aug 1
t_yrs <- (ts_fitting_R$t)/365
wt <- 2*3.14*freq_invYrs*t_yrs
EVI_fitting <- ts_fitting_R$EVI_smoothed2
# Model that sets w (as in TIMESAT)
model_GEE_harmonic <- lm(EVI_fitting~ t_yrs + cos(wt) + sin(wt))
plot(ts_fitting_R$t, EVI_fitting)
lines(ts_fitting_R$t, EVI_fitting, col = "green")
lines(ts_fitting_R$t, fitted(model_GEE_harmonic), col = "red")
length(fitted(model_GEE_harmonic))
length(t)
View(ts_fitting_R)
length(ts_fitting_R$t)
length(EVI_fitting)

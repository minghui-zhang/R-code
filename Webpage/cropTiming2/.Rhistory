# data must be stacked first by time period and then by region
# first index "year", second index "region" - i.e. have a column for region, then column for year
cell_tidy_DC_pdfo <- cell_tidy_DC_pdf[order(cell_tidy_DC_pdf$year) , ] # pdata.frame
# spml is the general wrapper function and the argument model controls the specification
# model = "within" for fixed effects; "random" for random effects, "pooling" for no effects
# spatial structure is specified by combining logical arguments lag (if TRUE, adds spatial autoregressive term in the dependent variable) and spatial.error (takes three values: "b", "kkp", or "none" for no spatial error correlation")
#cell_DC_FEDurbin = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, model="within", effect="twoways", lag=TRUE, spatial.error="none")
cell_DC_FEDurbin = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, model="within", effect="twoways", lag=TRUE, spatial.error="none")
lw
nrow(cell_sf_tidy_DC)
223*11
usalw
816/48
lw
nb
usalw
lw
?spml
print(listw)
print(lw)
View(lw)
cell_DC_FEDurbin = spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, index = NULL,
listw = usalw, model = "random", lag = TRUE, spatial.error = "b")
cell_DC_FEDurbin = spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, index = NULL,
model = "random", lag = TRUE, spatial.error = "b")
summary(cell_DC_FEDurbin)
View(cell_tidy_DC_pdfo)
cell_DC_FEDurbin = spml(plant ~ onset + lat, data=cell_tidy_DC_pdfo, listw=lw, index = NULL,
model = "random", lag = TRUE, spatial.error = "b")
summary(cell_DC_FEDurbin)
library(splm)
library(plm)
# filter for only DC cells
cell_sf_tidy <- cell_sf_tidy %>%  drop_na
cell_sf_tidy_DC <- cell_sf_tidy %>%
filter(intensity == "DC")
# filter out all cells where there isn't data for all years
cells_list <- list()
i <- 1
for (year in 2004:2014) {
cells_in_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == year,]
cells_list[[i]] <- cells_in_year$cell_ID
i <- i + 1
}
full_data_cells <- Reduce(base::intersect, cells_list)
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% full_data_cells, ]
# spatial Durbin model with region and time (twoways) fixed effect
#spatial weights matrix, convert to weights list object
#W5EX.lw = mat2listw(W5EX, style="W")
#class(W5EX.lw) # listw, nb
cell_sf_tidy_DC_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == 2014,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
# get only the regions with links, redo neighbors calc, filter the data for all years accordingly
cell_sf_tidy_DC_year <- cell_sf_tidy_DC_year[card(nb) != 0,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
linked_cells <- cell_sf_tidy_DC_year$cell_ID
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% linked_cells, ]
# convert data.frame to pdata.frame object to apply as panel data (use package plm)
cell_tidy_DC_pdf <- pdata.frame(cell_sf_tidy_DC, c("cell_ID","year"))
# data must be stacked first by time period and then by region
# first index "year", second index "region" - i.e. have a column for region, then column for year
cell_tidy_DC_pdfo <- cell_tidy_DC_pdf[order(cell_tidy_DC_pdf$year) , ] # pdata.frame
# spml is the general wrapper function and the argument model controls the specification
# model = "within" for fixed effects; "random" for random effects, "pooling" for no effects
# spatial structure is specified by combining logical arguments lag (if TRUE, adds spatial autoregressive term in the dependent variable) and spatial.error (takes three values: "b", "kkp", or "none" for no spatial error correlation")
#cell_DC_FEDurbin = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, model="within", effect="twoways", lag=TRUE, spatial.error="none")
cell_DC_model = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, index = NULL,
model = "random", lag = TRUE, spatial.error = "b")
summary(cell_DC_model)
cell_DC_model2 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, model="within", effect="twoways", lag=TRUE, spatial.error="none")
cell_DC_model2 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="within", lag=TRUE, spatial.error="none")
cell_DC_model1 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model = "random", lag = TRUE, spatial.error = "b")
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="within", lag=TRUE, spatial.error="kkp")
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="random", lag=TRUE, spatial.error="kkp")
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="individual", lag=TRUE, spatial.error="kkp")
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="pooling", lag=TRUE, spatial.error="kkp")
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="pooling", effect = "twoways", lag=TRUE, spatial.error="kkp")
cell_DC_model3
summary(cell_DC_model3)
cell_DC_model3$residuals
cell_DC_model4 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
lag = TRUE, spatial.error = "b", model = "within",
+ effect = "individual", method = "eigen")
cell_DC_model4 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
lag = TRUE, spatial.error = "b", model = "within", effect = "individual", method = "eigen")
View(Produc)
spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model = "within",
lag = TRUE, spatial.error = TRUE)
plot(cell_DC_model3$residuals)
plot(cell_DC_model3)
install.packages('alr')
plot(cell_DC_model3, which = c(1,2))
cell_DC_model3
cell_DC_model3$coefficients
plot(cell_DC_model3$fitted.values, cell_DC_model3$residuals, main = "fitted values vs residuals")
cell_DC_model3$fitted.values
range(cell_DC_model$fitted.values)
range(cell(cell_DC_model$residuals))
range(cell_DC_model$residuals))
range(cell_DC_model$residuals)
qqnorm(cell_DC_model3$residuals, pch = 1, frame = FALSE)
qqline(cell_DC_model3$residuals, col = "steelblue", lwd = 2)
test_plots <- function(model, model_name) {
# fitted values vs residuals
plot(cell_DC_model3$fitted.values, cell_DC_model3$residuals, main = paste("fitted values vs residuals", model_name))
# normal probability plot
qqnorm(cell_DC_model3$residuals, pch = 1, frame = FALSE, main = model_name)
qqline(cell_DC_model3$residuals, col = "steelblue", lwd = 2)
}
test_plots(cell_DC_model1, "model1")
cell_DC_model2 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = T)
source('E:/R-code/Modeling/code/spml_tutorial.R', echo=TRUE)
warnings()
W
listw
usalw
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
lw
View(usalw)
df
View(cell_tidy_DC_pdfo)
cell_DC_model2 = spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = T)
traceback()
?lag.listw
lw
View(lw)
View(listw)
sapply(lw$neighbours, length)
sapply(lw$weights, length)
sapply(lw$weights, length) - sapply(lw$neighbours, length)
library(splm)
library(plm)
# filter for only DC cells
cell_sf_tidy <- cell_sf_tidy %>%  drop_na
cell_sf_tidy_DC <- cell_sf_tidy %>%
filter(intensity == "DC")
# filter out all cells where there isn't data for all years
cells_list <- list()
i <- 1
for (year in 2004:2014) {
cells_in_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == year,]
cells_list[[i]] <- cells_in_year$cell_ID
i <- i + 1
}
full_data_cells <- Reduce(base::intersect, cells_list)
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% full_data_cells, ]
# spatial Durbin model with region and time (twoways) fixed effect
#spatial weights matrix, convert to weights list object
#W5EX.lw = mat2listw(W5EX, style="W")
#class(W5EX.lw) # listw, nb
cell_sf_tidy_DC_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == 2014,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
# get only the regions with links, redo neighbors calc, filter the data for all years accordingly
cell_sf_tidy_DC_year <- cell_sf_tidy_DC_year[card(nb) != 0,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
linked_cells <- cell_sf_tidy_DC_year$cell_ID
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% linked_cells, ]
# convert data.frame to pdata.frame object to apply as panel data (use package plm)
cell_tidy_DC_pdf <- pdata.frame(cell_sf_tidy_DC, c("cell_ID","year"))
# data must be stacked first by time period and then by region
# first index "year", second index "region" - i.e. have a column for region, then column for year
cell_tidy_DC_pdfo <- cell_tidy_DC_pdf[order(cell_tidy_DC_pdf$year) , ] # pdata.frame
# spml is the general wrapper function and the argument model controls the specification
# model = "within" for fixed effects; "random" for random effects, "pooling" for no effects
# spatial structure is specified by combining logical arguments lag (if TRUE, adds spatial autoregressive term in the dependent variable) and spatial.error (takes three values: "b", "kkp", or "none" for no spatial error correlation")
#cell_DC_FEDurbin = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, model="within", effect="twoways", lag=TRUE, spatial.error="none")
cell_DC_model1 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model = "random", lag = TRUE, spatial.error = "b")
library(splm)
library(plm)
# filter for only DC cells
cell_sf_tidy <- cell_sf_tidy %>%  drop_na
cell_sf_tidy_DC <- cell_sf_tidy %>%
filter(intensity == "DC")
# filter out all cells where there isn't data for all years
cells_list <- list()
i <- 1
for (year in 2004:2014) {
cells_in_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == year,]
cells_list[[i]] <- cells_in_year$cell_ID
i <- i + 1
}
full_data_cells <- Reduce(base::intersect, cells_list)
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% full_data_cells, ]
# spatial Durbin model with region and time (twoways) fixed effect
#spatial weights matrix, convert to weights list object
#W5EX.lw = mat2listw(W5EX, style="W")
#class(W5EX.lw) # listw, nb
cell_sf_tidy_DC_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == 2014,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
# get only the regions with links, redo neighbors calc, filter the data for all years accordingly
cell_sf_tidy_DC_year <- cell_sf_tidy_DC_year[card(nb) != 0,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
linked_cells <- cell_sf_tidy_DC_year$cell_ID
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% linked_cells, ]
# convert data.frame to pdata.frame object to apply as panel data (use package plm)
cell_tidy_DC_pdf <- pdata.frame(cell_sf_tidy_DC, c("cell_ID","year"))
# data must be stacked first by time period and then by region
# first index "year", second index "region" - i.e. have a column for region, then column for year
cell_tidy_DC_pdfo <- cell_tidy_DC_pdf[order(cell_tidy_DC_pdf$year) , ] # pdata.frame
# spml is the general wrapper function and the argument model controls the specification
# model = "within" for fixed effects; "random" for random effects, "pooling" for no effects
# spatial structure is specified by combining logical arguments lag (if TRUE, adds spatial autoregressive term in the dependent variable) and spatial.error (takes three values: "b", "kkp", or "none" for no spatial error correlation")
#cell_DC_FEDurbin = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, model="within", effect="twoways", lag=TRUE, spatial.error="none")
cell_DC_model1 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model = "random", lag = TRUE, spatial.error = "b")
# this doesn't work, object lengths differ
#cell_DC_model2 = spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = T)
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="pooling", effect = "twoways", lag=TRUE, spatial.error="kkp")
summary(cell_DC_model3)
# test the models
test_plots <- function(model, model_name) {
plot(cell_DC_model$residuals, main = paste("residual vs index", model_name))
# fitted values vs residuals
plot(cell_DC_model3$fitted.values, cell_DC_model3$residuals, main = paste("fitted values vs residuals", model_name))
# normal probability plot
qqnorm(cell_DC_model3$residuals, pch = 1, frame = FALSE, main = model_name)
qqline(cell_DC_model3$residuals, col = "steelblue", lwd = 2)
}
test_plots(cell_DC_model1, "model1")
test_plots(cell_DC_model3, "model3")
spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = T)
traceback()
?lag.listw
lag.listw(lw, c(1,2))
?spml
spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = F)
spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = T, zero.policy = TRUE)
browser()
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="pooling", effect = "twoways", lag=TRUE, spatial.error="kkp")
browser()
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="pooling", effect = "twoways", lag=TRUE, spatial.error="kkp")
library(splm)
library(plm)
# filter for only DC cells
cell_sf_tidy <- cell_sf_tidy %>%  drop_na
cell_sf_tidy_DC <- cell_sf_tidy %>%
filter(intensity == "DC")
# filter out all cells where there isn't data for all years
cells_list <- list()
i <- 1
for (year in 2004:2014) {
cells_in_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == year,]
cells_list[[i]] <- cells_in_year$cell_ID
i <- i + 1
}
full_data_cells <- Reduce(base::intersect, cells_list)
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% full_data_cells, ]
# spatial Durbin model with region and time (twoways) fixed effect
#spatial weights matrix, convert to weights list object
#W5EX.lw = mat2listw(W5EX, style="W")
#class(W5EX.lw) # listw, nb
cell_sf_tidy_DC_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == 2014,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
# get only the regions with links, redo neighbors calc, filter the data for all years accordingly
cell_sf_tidy_DC_year <- cell_sf_tidy_DC_year[card(nb) != 0,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
linked_cells <- cell_sf_tidy_DC_year$cell_ID
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% linked_cells, ]
# convert data.frame to pdata.frame object to apply as panel data (use package plm)
cell_tidy_DC_pdf <- pdata.frame(cell_sf_tidy_DC, c("cell_ID","year"))
# data must be stacked first by time period and then by region
# first index "year", second index "region" - i.e. have a column for region, then column for year
cell_tidy_DC_pdfo <- cell_tidy_DC_pdf[order(cell_tidy_DC_pdf$year) , ] # pdata.frame
# spml is the general wrapper function and the argument model controls the specification
# model = "within" for fixed effects; "random" for random effects, "pooling" for no effects
# spatial structure is specified by combining logical arguments lag (if TRUE, adds spatial autoregressive term in the dependent variable) and spatial.error (takes three values: "b", "kkp", or "none" for no spatial error correlation")
#cell_DC_FEDurbin = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, model="within", effect="twoways", lag=TRUE, spatial.error="none")
cell_DC_model1 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model = "random", lag = TRUE, spatial.error = "b")
# this doesn't work, object lengths differ
cell_DC_model2 = spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = T)
library(splm)
library(plm)
# filter for only DC cells
cell_sf_tidy <- cell_sf_tidy %>%  drop_na
cell_sf_tidy_DC <- cell_sf_tidy %>%
filter(intensity == "DC")
# filter out all cells where there isn't data for all years
cells_list <- list()
i <- 1
for (year in 2004:2014) {
cells_in_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == year,]
cells_list[[i]] <- cells_in_year$cell_ID
i <- i + 1
}
full_data_cells <- Reduce(base::intersect, cells_list)
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% full_data_cells, ]
# spatial Durbin model with region and time (twoways) fixed effect
#spatial weights matrix, convert to weights list object
#W5EX.lw = mat2listw(W5EX, style="W")
#class(W5EX.lw) # listw, nb
cell_sf_tidy_DC_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == 2014,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
# get only the regions with links, redo neighbors calc, filter the data for all years accordingly
cell_sf_tidy_DC_year <- cell_sf_tidy_DC_year[card(nb) != 0,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
linked_cells <- cell_sf_tidy_DC_year$cell_ID
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% linked_cells, ]
# convert data.frame to pdata.frame object to apply as panel data (use package plm)
cell_tidy_DC_pdf <- pdata.frame(cell_sf_tidy_DC, c("cell_ID","year"))
# data must be stacked first by time period and then by region
# first index "year", second index "region" - i.e. have a column for region, then column for year
cell_tidy_DC_pdfo <- cell_tidy_DC_pdf[order(cell_tidy_DC_pdf$year) , ] # pdata.frame
# spml is the general wrapper function and the argument model controls the specification
# model = "within" for fixed effects; "random" for random effects, "pooling" for no effects
# spatial structure is specified by combining logical arguments lag (if TRUE, adds spatial autoregressive term in the dependent variable) and spatial.error (takes three values: "b", "kkp", or "none" for no spatial error correlation")
#cell_DC_FEDurbin = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, model="within", effect="twoways", lag=TRUE, spatial.error="none")
cell_DC_model1 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model = "random", lag = TRUE, spatial.error = "b")
# this doesn't work, object lengths differ
browser()
cell_DC_model2 = spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = T)
res_spatial$residuals
plot(res_spatial$fitted.values, res_spatial$residuals)
cell_DC_model1 = spml(plant ~ onset + lat + year  +1, data=cell_tidy_DC_pdfo, listw=lw,
model = "random", lag = TRUE, spatial.error = "b")
test_plots(cell_DC_model1, "model1")
source('E:/R-code/Modeling/code/spml_tutorial.R', echo=TRUE)
plot(res_spatial$fitted.values, res_spatial$residuals)
library(shiny)
library(leaflet)
library(dplyr)
library(rgdal)
library(raster)
library(leafpop)
library(ggplot2)
library(spatialEco)
df <- readRDS("./cell_spdf.rds")
setwd("E:/R-code/Webpage/cropTiming2")
df <- readRDS("./cell_spdf.rds")
create_graph <- function(df_row) {
cell_ID_value <- df_row["cell_ID"]
#print('generating graph for cell')
print(cell_ID_value)
# get all years corresponding to this cell
cell_df <- as.data.frame(df)[as.data.frame(df)$cell_ID == cell_ID_value,]
return(
ggplot(cell_df, aes(x = year, y = plant, col = intensity)) +
geom_point(size = 1) +
#geom_point(aes(x = year, y = onset)) +
theme_bw()
)
}
all_graphs_list <- apply(as.data.frame(df[1:10,]), MARGIN = 1, FUN = create_graph)
class(all_graphs_list)
all_graphs_list <- apply(as.data.frame(df), MARGIN = 1, FUN = create_graph)
df$graph <- all_graphs_list
all_graphs_list
saveRDS(all_graphs_list, file = "all_graphs_list.rds")
all_graphs_list <- readRDS("./all_graphs_list.rds")
df
df$graph <- all_graphs_list
names(df)
runApp()
df[df$intensity == "SC" &  df$year == 2010,]
df <- df[df$intensity == "SC" &  df$year == 2010,]
all_graphs_list <- apply(as.data.frame(df), MARGIN = 1, FUN = create_graph)
saveRDS(all_graphs_list, file = "all_graphs_list.rds")
all_graphs_list[1:3]
runApp()
graphs_list
all_graphs_list[1]
all_graphs_list[2]
all_graphs_list[-1]
runApp()
runApp()
runApp()
?mapview
install.packages('mapview')
library(mapview)
runApp()
runApp()
runApp()
SpatialPoints(matrix(c(-10, 10)), nrow = 1)
SpatialPoints(matrix(c(point_lon,point_lat), nrow = 1))
SpatialPoints(matrix(c(1,1), nrow = 1))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
library(ggplot2)
library(tidyverse)
library(broom)
library(dplyr)
library(rgdal)
library(rgeos)
library(raster)
library(sf)
library(sp)
library(tmap)
library(viridis)
library(spdep)
library(spatialreg)
library(lmtest)
library(Metrics) # for rmse
library(leaflet)
library(leaps) # stepwise model selection
#E:/R-code/Modeling/code/FCN_clean_csvs.R
#~/Documents/R-code
source('E:/R-code/Modeling/code/FCN_clean_csvs.R')
source('E:/R-code/Modeling/code/FCN_plotting.R')
source('E:/R-code/Modeling/code/FCN_sample_data.R')
source('E:/R-code/Modeling/code/FCN_run_model_spatial_sampled.R')
MT_outline <- readOGR(dsn = 'E:/R-code/Modeling/data/shp/MatoGrossoOutline', layer = 'MatoGrossoOutline')
crs(MT_outline) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
median_cell_raw <- read.csv('E:/R-code/Modeling/data/median_onset_cell_v2.csv')
percentile5_cell_raw <- read.csv('E:/R-code/Modeling/data/percentile5_onset_cell_v2.csv')
percentile95_cell_raw <- read.csv('E:/R-code/Modeling/data/percentile95_onset_cell_v2.csv')
grid_1deg <- readOGR(dsn = 'E:/R-code/Modeling/data/shp/grid_1deg', layer = 'grid_1deg')
munis <- readOGR(dsn = 'E:/R-code/Modeling/data/shp/munis', layer = 'munis_SHP')
crs(munis) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
cell_sf <- st_read(dsn = 'E:/R-code/Modeling/data/shp/median_onset_cell', layer = 'median_onset_cell_SHP')
min_soy_area <- 2 #km2. min area of total or SC/DC soy in cell, muni or property to be considered in model
# CSV DATA -----------------------------------------------------------------------------------------------------------------
# median cell
median_cell <- median_cell_raw %>% delete_cols_median_cell() %>%
rename_cols_median_cell()
median_cell$plant_stat_type <- rep('median', nrow(median_cell))
# percentiles
percentile5_cell <- percentile5_cell_raw %>% rename_cols_percentile_cell()
percentile95_cell <- percentile95_cell_raw %>% rename_cols_percentile_cell()
# SF DATA ------------------------------------------------------------------------------------------------
# get cell_ID column for median
cell_sf$cell_ID <- median_cell$cell_ID
cell_sf$cell_ID <- sapply(as.character(cell_sf$cell_ID), clean_cell_ID)
# join median, percentile data to cell_sf
# cell_sf has median information, but copy it and put in percentile info for DC and SC plant
cell_sf$plant_stat_type <- rep("median", nrow(cell_sf))
cell_sf_percentile5 <- cell_sf
cell_sf_percentile5$SC_plant <- percentile5_cell$SC_plant
cell_sf_percentile5$DC_plant <- percentile5_cell$DC_plant
cell_sf_percentile5$plant_stat_type <- rep("percentile5", nrow(cell_sf_percentile5))
cell_sf_percentile95 <- cell_sf
cell_sf_percentile95$SC_plant <- percentile95_cell$SC_plant
cell_sf_percentile95$DC_plant <- percentile95_cell$DC_plant
cell_sf_percentile95$plant_stat_type <- rep("percentile95", nrow(cell_sf_percentile95))
cell_sf <- rbind(cell_sf, cell_sf_percentile5, cell_sf_percentile95)
cell_sf_tidy <- cell_sf %>% tidy_by_intensity_plant("SC_plant", "DC_plant") %>%
#tidy_by_intensity_delay("SC_delay", "DC_delay") %>%
dplyr::select(-c(SC_harvest, DC_harvest)) %>%
categorize_regions_cell_sf_tidy() # categorize cells into four regions
cell_sf_tidy$year_index <- cell_sf_tidy$year - 2003
cell_sf_tidy$year_factor <- as.factor(cell_sf_tidy$year)
cell_sf_tidy <- cell_sf_tidy %>%  drop_na
# for app.R
cell_sf_tidy <- cell_sf_tidy %>%  drop_na %>%
mutate(year_factor = as.factor(year))
saveRDS(as(cell_sf_tidy, 'Spatial'), "./cell_spdf.rds")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()

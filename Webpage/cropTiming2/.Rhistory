lw <- nb2listw(nb, zero.policy = TRUE) # listw object
# get only the regions with links, redo neighbors calc, filter the data for all years accordingly
cell_sf_tidy_DC_year <- cell_sf_tidy_DC_year[card(nb) != 0,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
linked_cells <- cell_sf_tidy_DC_year$cell_ID
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% linked_cells, ]
# convert data.frame to pdata.frame object to apply as panel data (use package plm)
cell_tidy_DC_pdf <- pdata.frame(cell_sf_tidy_DC, c("cell_ID","year"))
# data must be stacked first by time period and then by region
# first index "year", second index "region" - i.e. have a column for region, then column for year
cell_tidy_DC_pdfo <- cell_tidy_DC_pdf[order(cell_tidy_DC_pdf$year) , ] # pdata.frame
# spml is the general wrapper function and the argument model controls the specification
# model = "within" for fixed effects; "random" for random effects, "pooling" for no effects
# spatial structure is specified by combining logical arguments lag (if TRUE, adds spatial autoregressive term in the dependent variable) and spatial.error (takes three values: "b", "kkp", or "none" for no spatial error correlation")
#cell_DC_FEDurbin = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, model="within", effect="twoways", lag=TRUE, spatial.error="none")
cell_DC_model = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, index = NULL,
model = "random", lag = TRUE, spatial.error = "b")
summary(cell_DC_model)
cell_DC_model2 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, model="within", effect="twoways", lag=TRUE, spatial.error="none")
cell_DC_model2 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="within", lag=TRUE, spatial.error="none")
cell_DC_model1 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model = "random", lag = TRUE, spatial.error = "b")
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="within", lag=TRUE, spatial.error="kkp")
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="random", lag=TRUE, spatial.error="kkp")
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="individual", lag=TRUE, spatial.error="kkp")
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="pooling", lag=TRUE, spatial.error="kkp")
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="pooling", effect = "twoways", lag=TRUE, spatial.error="kkp")
cell_DC_model3
summary(cell_DC_model3)
cell_DC_model3$residuals
cell_DC_model4 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
lag = TRUE, spatial.error = "b", model = "within",
+ effect = "individual", method = "eigen")
cell_DC_model4 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
lag = TRUE, spatial.error = "b", model = "within", effect = "individual", method = "eigen")
View(Produc)
spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model = "within",
lag = TRUE, spatial.error = TRUE)
plot(cell_DC_model3$residuals)
plot(cell_DC_model3)
install.packages('alr')
plot(cell_DC_model3, which = c(1,2))
cell_DC_model3
cell_DC_model3$coefficients
plot(cell_DC_model3$fitted.values, cell_DC_model3$residuals, main = "fitted values vs residuals")
cell_DC_model3$fitted.values
range(cell_DC_model$fitted.values)
range(cell(cell_DC_model$residuals))
range(cell_DC_model$residuals))
range(cell_DC_model$residuals)
qqnorm(cell_DC_model3$residuals, pch = 1, frame = FALSE)
qqline(cell_DC_model3$residuals, col = "steelblue", lwd = 2)
test_plots <- function(model, model_name) {
# fitted values vs residuals
plot(cell_DC_model3$fitted.values, cell_DC_model3$residuals, main = paste("fitted values vs residuals", model_name))
# normal probability plot
qqnorm(cell_DC_model3$residuals, pch = 1, frame = FALSE, main = model_name)
qqline(cell_DC_model3$residuals, col = "steelblue", lwd = 2)
}
test_plots(cell_DC_model1, "model1")
cell_DC_model2 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = T)
source('E:/R-code/Modeling/code/spml_tutorial.R', echo=TRUE)
warnings()
W
listw
usalw
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
lw
View(usalw)
df
View(cell_tidy_DC_pdfo)
cell_DC_model2 = spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = T)
traceback()
?lag.listw
lw
View(lw)
View(listw)
sapply(lw$neighbours, length)
sapply(lw$weights, length)
sapply(lw$weights, length) - sapply(lw$neighbours, length)
library(splm)
library(plm)
# filter for only DC cells
cell_sf_tidy <- cell_sf_tidy %>%  drop_na
cell_sf_tidy_DC <- cell_sf_tidy %>%
filter(intensity == "DC")
# filter out all cells where there isn't data for all years
cells_list <- list()
i <- 1
for (year in 2004:2014) {
cells_in_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == year,]
cells_list[[i]] <- cells_in_year$cell_ID
i <- i + 1
}
full_data_cells <- Reduce(base::intersect, cells_list)
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% full_data_cells, ]
# spatial Durbin model with region and time (twoways) fixed effect
#spatial weights matrix, convert to weights list object
#W5EX.lw = mat2listw(W5EX, style="W")
#class(W5EX.lw) # listw, nb
cell_sf_tidy_DC_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == 2014,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
# get only the regions with links, redo neighbors calc, filter the data for all years accordingly
cell_sf_tidy_DC_year <- cell_sf_tidy_DC_year[card(nb) != 0,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
linked_cells <- cell_sf_tidy_DC_year$cell_ID
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% linked_cells, ]
# convert data.frame to pdata.frame object to apply as panel data (use package plm)
cell_tidy_DC_pdf <- pdata.frame(cell_sf_tidy_DC, c("cell_ID","year"))
# data must be stacked first by time period and then by region
# first index "year", second index "region" - i.e. have a column for region, then column for year
cell_tidy_DC_pdfo <- cell_tidy_DC_pdf[order(cell_tidy_DC_pdf$year) , ] # pdata.frame
# spml is the general wrapper function and the argument model controls the specification
# model = "within" for fixed effects; "random" for random effects, "pooling" for no effects
# spatial structure is specified by combining logical arguments lag (if TRUE, adds spatial autoregressive term in the dependent variable) and spatial.error (takes three values: "b", "kkp", or "none" for no spatial error correlation")
#cell_DC_FEDurbin = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, model="within", effect="twoways", lag=TRUE, spatial.error="none")
cell_DC_model1 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model = "random", lag = TRUE, spatial.error = "b")
library(splm)
library(plm)
# filter for only DC cells
cell_sf_tidy <- cell_sf_tidy %>%  drop_na
cell_sf_tidy_DC <- cell_sf_tidy %>%
filter(intensity == "DC")
# filter out all cells where there isn't data for all years
cells_list <- list()
i <- 1
for (year in 2004:2014) {
cells_in_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == year,]
cells_list[[i]] <- cells_in_year$cell_ID
i <- i + 1
}
full_data_cells <- Reduce(base::intersect, cells_list)
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% full_data_cells, ]
# spatial Durbin model with region and time (twoways) fixed effect
#spatial weights matrix, convert to weights list object
#W5EX.lw = mat2listw(W5EX, style="W")
#class(W5EX.lw) # listw, nb
cell_sf_tidy_DC_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == 2014,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
# get only the regions with links, redo neighbors calc, filter the data for all years accordingly
cell_sf_tidy_DC_year <- cell_sf_tidy_DC_year[card(nb) != 0,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
linked_cells <- cell_sf_tidy_DC_year$cell_ID
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% linked_cells, ]
# convert data.frame to pdata.frame object to apply as panel data (use package plm)
cell_tidy_DC_pdf <- pdata.frame(cell_sf_tidy_DC, c("cell_ID","year"))
# data must be stacked first by time period and then by region
# first index "year", second index "region" - i.e. have a column for region, then column for year
cell_tidy_DC_pdfo <- cell_tidy_DC_pdf[order(cell_tidy_DC_pdf$year) , ] # pdata.frame
# spml is the general wrapper function and the argument model controls the specification
# model = "within" for fixed effects; "random" for random effects, "pooling" for no effects
# spatial structure is specified by combining logical arguments lag (if TRUE, adds spatial autoregressive term in the dependent variable) and spatial.error (takes three values: "b", "kkp", or "none" for no spatial error correlation")
#cell_DC_FEDurbin = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, model="within", effect="twoways", lag=TRUE, spatial.error="none")
cell_DC_model1 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model = "random", lag = TRUE, spatial.error = "b")
# this doesn't work, object lengths differ
#cell_DC_model2 = spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = T)
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="pooling", effect = "twoways", lag=TRUE, spatial.error="kkp")
summary(cell_DC_model3)
# test the models
test_plots <- function(model, model_name) {
plot(cell_DC_model$residuals, main = paste("residual vs index", model_name))
# fitted values vs residuals
plot(cell_DC_model3$fitted.values, cell_DC_model3$residuals, main = paste("fitted values vs residuals", model_name))
# normal probability plot
qqnorm(cell_DC_model3$residuals, pch = 1, frame = FALSE, main = model_name)
qqline(cell_DC_model3$residuals, col = "steelblue", lwd = 2)
}
test_plots(cell_DC_model1, "model1")
test_plots(cell_DC_model3, "model3")
spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = T)
traceback()
?lag.listw
lag.listw(lw, c(1,2))
?spml
spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = F)
spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = T, zero.policy = TRUE)
browser()
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="pooling", effect = "twoways", lag=TRUE, spatial.error="kkp")
browser()
cell_DC_model3 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model="pooling", effect = "twoways", lag=TRUE, spatial.error="kkp")
library(splm)
library(plm)
# filter for only DC cells
cell_sf_tidy <- cell_sf_tidy %>%  drop_na
cell_sf_tidy_DC <- cell_sf_tidy %>%
filter(intensity == "DC")
# filter out all cells where there isn't data for all years
cells_list <- list()
i <- 1
for (year in 2004:2014) {
cells_in_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == year,]
cells_list[[i]] <- cells_in_year$cell_ID
i <- i + 1
}
full_data_cells <- Reduce(base::intersect, cells_list)
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% full_data_cells, ]
# spatial Durbin model with region and time (twoways) fixed effect
#spatial weights matrix, convert to weights list object
#W5EX.lw = mat2listw(W5EX, style="W")
#class(W5EX.lw) # listw, nb
cell_sf_tidy_DC_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == 2014,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
# get only the regions with links, redo neighbors calc, filter the data for all years accordingly
cell_sf_tidy_DC_year <- cell_sf_tidy_DC_year[card(nb) != 0,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
linked_cells <- cell_sf_tidy_DC_year$cell_ID
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% linked_cells, ]
# convert data.frame to pdata.frame object to apply as panel data (use package plm)
cell_tidy_DC_pdf <- pdata.frame(cell_sf_tidy_DC, c("cell_ID","year"))
# data must be stacked first by time period and then by region
# first index "year", second index "region" - i.e. have a column for region, then column for year
cell_tidy_DC_pdfo <- cell_tidy_DC_pdf[order(cell_tidy_DC_pdf$year) , ] # pdata.frame
# spml is the general wrapper function and the argument model controls the specification
# model = "within" for fixed effects; "random" for random effects, "pooling" for no effects
# spatial structure is specified by combining logical arguments lag (if TRUE, adds spatial autoregressive term in the dependent variable) and spatial.error (takes three values: "b", "kkp", or "none" for no spatial error correlation")
#cell_DC_FEDurbin = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, model="within", effect="twoways", lag=TRUE, spatial.error="none")
cell_DC_model1 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model = "random", lag = TRUE, spatial.error = "b")
# this doesn't work, object lengths differ
cell_DC_model2 = spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = T)
library(splm)
library(plm)
# filter for only DC cells
cell_sf_tidy <- cell_sf_tidy %>%  drop_na
cell_sf_tidy_DC <- cell_sf_tidy %>%
filter(intensity == "DC")
# filter out all cells where there isn't data for all years
cells_list <- list()
i <- 1
for (year in 2004:2014) {
cells_in_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == year,]
cells_list[[i]] <- cells_in_year$cell_ID
i <- i + 1
}
full_data_cells <- Reduce(base::intersect, cells_list)
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% full_data_cells, ]
# spatial Durbin model with region and time (twoways) fixed effect
#spatial weights matrix, convert to weights list object
#W5EX.lw = mat2listw(W5EX, style="W")
#class(W5EX.lw) # listw, nb
cell_sf_tidy_DC_year <- cell_sf_tidy_DC[cell_sf_tidy_DC$year == 2014,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
# get only the regions with links, redo neighbors calc, filter the data for all years accordingly
cell_sf_tidy_DC_year <- cell_sf_tidy_DC_year[card(nb) != 0,]
nb <- poly2nb(cell_sf_tidy_DC_year) # only for ONE year
lw <- nb2listw(nb, zero.policy = TRUE) # listw object
linked_cells <- cell_sf_tidy_DC_year$cell_ID
cell_sf_tidy_DC <- cell_sf_tidy_DC[cell_sf_tidy_DC$cell_ID %in% linked_cells, ]
# convert data.frame to pdata.frame object to apply as panel data (use package plm)
cell_tidy_DC_pdf <- pdata.frame(cell_sf_tidy_DC, c("cell_ID","year"))
# data must be stacked first by time period and then by region
# first index "year", second index "region" - i.e. have a column for region, then column for year
cell_tidy_DC_pdfo <- cell_tidy_DC_pdf[order(cell_tidy_DC_pdf$year) , ] # pdata.frame
# spml is the general wrapper function and the argument model controls the specification
# model = "within" for fixed effects; "random" for random effects, "pooling" for no effects
# spatial structure is specified by combining logical arguments lag (if TRUE, adds spatial autoregressive term in the dependent variable) and spatial.error (takes three values: "b", "kkp", or "none" for no spatial error correlation")
#cell_DC_FEDurbin = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw, model="within", effect="twoways", lag=TRUE, spatial.error="none")
cell_DC_model1 = spml(plant ~ onset + lat + year, data=cell_tidy_DC_pdfo, listw=lw,
model = "random", lag = TRUE, spatial.error = "b")
# this doesn't work, object lengths differ
browser()
cell_DC_model2 = spml(plant ~ onset, data=cell_tidy_DC_pdfo, listw=lw, effect = "individual", model="within", spatial.error="none", lag = T)
res_spatial$residuals
plot(res_spatial$fitted.values, res_spatial$residuals)
cell_DC_model1 = spml(plant ~ onset + lat + year  +1, data=cell_tidy_DC_pdfo, listw=lw,
model = "random", lag = TRUE, spatial.error = "b")
test_plots(cell_DC_model1, "model1")
source('E:/R-code/Modeling/code/spml_tutorial.R', echo=TRUE)
plot(res_spatial$fitted.values, res_spatial$residuals)
shiny::runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
?mget
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
runApp('E:/R-code/Webpage/cropTiming2')
graph_popup
?class
runApp('E:/R-code/Webpage/cropTiming2')
class(df)
df <- readRDS("./cell_spdf.rds")
setwd("E:/R-code/Webpage/cropTiming2")
df <- readRDS("./cell_spdf.rds")
df$cell_ID
df[df$cell_ID == "+3673+4841",]
?apply
create_graph <- function(df_row) {
cell_ID_value <- df_row$cell_ID
# get all years corresponding to this cell
cell_df <- df[df$cell_ID == cell_ID_value,]
return(
ggplot(cell_df, aes(x = year, y = plant)) +
geom_point(size = 1) +
theme_bw()
)
}
apply(df, MARGIN = 1, FUN = create_graph)
apply(as.data.frame(df), MARGIN = 1, FUN = create_graph)
create_graph <- function(df_row) {
cell_ID_value <- as.data.frae(df_row)$cell_ID
# get all years corresponding to this cell
cell_df <- df[df$cell_ID == cell_ID_value,]
return(
ggplot(cell_df, aes(x = year, y = plant)) +
geom_point(size = 1) +
theme_bw()
)
}
apply(as.data.frame(df), MARGIN = 1, FUN = create_graph)
create_graph <- function(df_row) {
cell_ID_value <- as.data.frame(df_row)$cell_ID
# get all years corresponding to this cell
cell_df <- df[df$cell_ID == cell_ID_value,]
return(
ggplot(cell_df, aes(x = year, y = plant)) +
geom_point(size = 1) +
theme_bw()
)
}
apply(as.data.frame(df), MARGIN = 1, FUN = create_graph)
apply(as.data.frame(df)[1:10], MARGIN = 1, FUN = create_graph)
as.data.frame(df)[1:2]
as.data.frame(df)
as.data.frame(df)[1:2,]
apply(as.data.frame(df)[1:2,], MARGIN = 1, FUN = create_graph)
create_graph <- function(df_row) {
cell_ID_value <- as.data.frame(df_row)$cell_ID
print('cell ID')
print(cell_ID_value)
# get all years corresponding to this cell
cell_df <- df[df$cell_ID == cell_ID_value,]
print('cell_df')
print(cell_df)
return(
ggplot(cell_df, aes(x = year, y = plant)) +
geom_point(size = 1) +
theme_bw()
)
}
apply(as.data.frame(df)[1:2,], MARGIN = 1, FUN = create_graph)
create_graph <- function(df_row) {
print('df_row')
print(df_row)
cell_ID_value <- as.data.frame(df_row)$cell_ID
print('cell ID')
print(cell_ID_value)
# get all years corresponding to this cell
cell_df <- as.data.frame(df)[as.data.frame(df)$cell_ID == cell_ID_value,]
print('cell_df')
print(cell_df)
return(
ggplot(cell_df, aes(x = year, y = plant)) +
geom_point(size = 1) +
theme_bw()
)
}
apply(as.data.frame(df)[1:2,], MARGIN = 1, FUN = create_graph)
create_graph <- function(df_row) {
print('df_row')
print(df_row)
cell_ID_value <- df_row["cell_ID"]
print('cell ID')
print(cell_ID_value)
# get all years corresponding to this cell
cell_df <- as.data.frame(df)[as.data.frame(df)$cell_ID == cell_ID_value,]
print('cell_df')
print(cell_df)
return(
ggplot(cell_df, aes(x = year, y = plant)) +
geom_point(size = 1) +
theme_bw()
)
}
apply(as.data.frame(df)[1:2,], MARGIN = 1, FUN = create_graph)
na.rm(df)
drop_na(df)
?drop_na
library(tidyr)
drop_na(df)
install.packages('spatialEco')
library(spatialEco)
sp.na.omit(df, margin = 1)
result <- sp.na.omit(df, margin = 1)
result
df
View(df)
df@data
df@data$plant
sum(df@data$plant > 1)
graphs_list <- apply(as.data.frame(df)[1:2,], MARGIN = 1, FUN = create_graph)
graphs_list <- apply(as.data.frame(df)[1:2,], MARGIN = 1, FUN = create_graph)
graphs_list
create_graph <- function(df_row) {
print('df_row')
print(df_row)
cell_ID_value <- df_row["cell_ID"]
print('cell ID')
print(cell_ID_value)
# get all years corresponding to this cell
cell_df <- as.data.frame(df)[as.data.frame(df)$cell_ID == cell_ID_value,]
print('cell_df')
print(cell_df)
return(
ggplot(cell_df, aes(x = year, y = plant, col = intensity)) +
geom_point(size = 1) +
geom_point(aes(x = year, y = onset)) +
theme_bw()
)
}
graphs_list <- apply(as.data.frame(df)[1:2,], MARGIN = 1, FUN = create_graph)
graphs_list
create_graph <- function(df_row) {
print('df_row')
print(df_row)
cell_ID_value <- df_row["cell_ID"]
print('cell ID')
print(cell_ID_value)
# get all years corresponding to this cell
cell_df <- as.data.frame(df)[as.data.frame(df)$cell_ID == cell_ID_value,]
print('cell_df')
print(cell_df)
return(
ggplot(cell_df, aes(x = year, y = plant, col = intensity)) +
geom_point(size = 1) +
#geom_point(aes(x = year, y = onset)) +
theme_bw()
)
}
graphs_list <- apply(as.data.frame(df)[1:2,], MARGIN = 1, FUN = create_graph)
graphs_list
df[1:3,]
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
filteredData()
all_graphs_list <- apply(as.data.frame(df[1:3,]), MARGIN = 1, FUN = create_graph)
all_graphs_list
all_graphs_list <- apply(as.data.frame(df), MARGIN = 1, FUN = create_graph)
create_graph <- function(df_row) {
cell_ID_value <- df_row["cell_ID"]
#print('generating graph for cell')
print(cell_ID_value)
# get all years corresponding to this cell
cell_df <- as.data.frame(df)[as.data.frame(df)$cell_ID == cell_ID_value,]
return(
ggplot(cell_df, aes(x = year, y = plant, col = intensity)) +
geom_point(size = 1) +
#geom_point(aes(x = year, y = onset)) +
theme_bw()
)
}
print('generate graphs list')
all_graphs_list <- apply(as.data.frame(df), MARGIN = 1, FUN = create_graph)
create_graph <- function(df_row) {
cell_ID_value <- df_row["cell_ID"]
#print('generating graph for cell')
print(cell_ID_value)
# get all years corresponding to this cell
cell_df <- as.data.frame(df)[as.data.frame(df)$cell_ID == cell_ID_value,]
return(
ggplot(cell_df, aes(x = year, y = plant, col = intensity)) +
geom_point(size = 1) +
#geom_point(aes(x = year, y = onset)) +
theme_bw()
)
}
apply(as.data.frame(df[1:100,]), MARGIN = 1, FUN = create_graph)
df[1:4,]
print(df[1:4,])
test <- df[1:4,]
test
print(test)
View(test)
runApp()
class(all_graphs_list)
print(class(all_graphs_list))

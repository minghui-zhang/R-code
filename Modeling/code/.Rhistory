test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age", "onset_historicalRange")
test.interaction.vars <- c()
test2 <- do_lm(data = cell_tidy,
y.var = test.y.var,
x.vars = test.x.vars,
interaction.pairs = test.interaction.vars,
time.handle = test.time.handle,
spatial.fe.scale = test.spatial.fe.scale,
spatial.auto.model = test.spatial.auto.model,
crop.intensity = test.crop.intensity,
mask.soy.area = test.mask.soy.area)
print('full model')
evaluate_model(test2, test.x.vars, cell_tidy, "full model")
anova(test1, test2)
# list of numeric x variable names, to be used in multicollinearity test
numeric.x.var.names <- c("onset", "latitude", "longitude", "onset_historicalRange", "year", "year_index")
# do linear model
# NEEDS year fixed effect, spatial fixed effect, FE vs ME, spatial autocorrelation handling
do_lm <- function(data, y.var, time.handle, spatial.fe.scale, spatial.auto.model, x.vars, interaction.pairs,
crop.intensity, mask.soy.area) {
# options:
# x.vars = vector of predictors, names of variables are in quotes
# crop.intensity = "none", "DC", "SC"
# time.handle = "none", "year.trend" (uses year_index as x var), "year.fe" (uses year as fixed or mixed effect)
# spatial.fe.scale = "none", "regions.4", "municipality", "grid.1deg", "geo.weighted"
# spatial.auto.model = "none", "spatial.lag", "spatial.error"
# interaction.pairs = vector of interactions as will be written in the lm formula, e.g. onset*latitude
# mask.soy.area = TRUE or FALSE, if TRUE take out rows with total soy area below min_soy_area
# subset the data  --------------------------------------------------------------------------------------------------------
# get only the desired cropping intensity
data.subset <- if(crop.intensity == "none") {
data
} else {
data[data$intensity == crop.intensity,]
}
# get rid of observations with low soy area
data.subset <- if(mask.soy.area) {
data.subset[data.subset$total_planted_area_km2 >= min_soy_area,]
}
# define the formula ------------------------------------------------------------------------------------------------------
# define the basic formula
formula.string <- paste(y.var, paste(c(x.vars, interaction.pairs), collapse = " + "), sep = " ~ ")
# check for time.handle
if (time.handle == "year.trend") {formula.string <- paste(formula.string, "year_index", sep = " + ")}
f <- as.formula(formula.string)
# do the model -------------------------------------------------------------------------------------------------------------
# evaluate model. note, simpler alternative: model <- lm(f, data = data.subset)
model <- eval(bquote(   lm(.(f), data = data.subset)   ))
return(model)
}
evaluate_model <- function(lm_results, test.x.vars, orig_data, title) {
print(title)
print(summary(lm_results))
plot(lm_results, which = c(1,2), main = title) # test error is homoscedastic, zero mean, normal
# test pearson's correlation for numeric variables used
df <- orig_data %>% subset(select = test.x.vars[test.x.vars %in% numeric.x.var.names])
test.corr <- cor(df)
print(c('predictor correlation matrix', title))
print(test.corr)
}
# Reduced model -------------------------------------------------------------------------------------------
test.y.var <- "plant_median"
# , "latitude", "longitude", "intensity", "soy_age", "region", "onset_historicalRange", "year_index"
test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age")
# note, doing x*y will create x + y + x:y, while x:y doesn't necessarily include x + y
test.interaction.vars <- c() #c("onset:latitude", "onset:longitude", "onset:intensity", "onset:soy_age", "onset:region")
test.time.handle <- "none"
test.spatial.fe.scale <- "none"
test.spatial.auto.model <- "none"
test.crop.intensity <- "none"
test.mask.soy.area <- TRUE
test1 <- do_lm(data = cell_tidy,
y.var = test.y.var,
x.vars = test.x.vars,
interaction.pairs = test.interaction.vars,
time.handle = test.time.handle,
spatial.fe.scale = test.spatial.fe.scale,
spatial.auto.model = test.spatial.auto.model,
crop.intensity = test.crop.intensity,
mask.soy.area = test.mask.soy.area)
print('reduced model')
evaluate_model(test1, test.x.vars, cell_tidy, "reduced model")
# 'Fuller' model -----------------------------------------------------------------------------------------
test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age")
test.interaction.vars <- c("onset:intensity")
test2 <- do_lm(data = cell_tidy,
y.var = test.y.var,
x.vars = test.x.vars,
interaction.pairs = test.interaction.vars,
time.handle = test.time.handle,
spatial.fe.scale = test.spatial.fe.scale,
spatial.auto.model = test.spatial.auto.model,
crop.intensity = test.crop.intensity,
mask.soy.area = test.mask.soy.area)
print('full model')
evaluate_model(test2, test.x.vars, cell_tidy, "full model")
anova(test1, test2)
# list of numeric x variable names, to be used in multicollinearity test
numeric.x.var.names <- c("onset", "latitude", "longitude", "onset_historicalRange", "year", "year_index")
# do linear model
# NEEDS year fixed effect, spatial fixed effect, FE vs ME, spatial autocorrelation handling
do_lm <- function(data, y.var, time.handle, spatial.fe.scale, spatial.auto.model, x.vars, interaction.pairs,
crop.intensity, mask.soy.area) {
# options:
# x.vars = vector of predictors, names of variables are in quotes
# crop.intensity = "none", "DC", "SC"
# time.handle = "none", "year.trend" (uses year_index as x var), "year.fe" (uses year as fixed or mixed effect)
# spatial.fe.scale = "none", "regions.4", "municipality", "grid.1deg", "geo.weighted"
# spatial.auto.model = "none", "spatial.lag", "spatial.error"
# interaction.pairs = vector of interactions as will be written in the lm formula, e.g. onset*latitude
# mask.soy.area = TRUE or FALSE, if TRUE take out rows with total soy area below min_soy_area
# subset the data  --------------------------------------------------------------------------------------------------------
# get only the desired cropping intensity
data.subset <- if(crop.intensity == "none") {
data
} else {
data[data$intensity == crop.intensity,]
}
# get rid of observations with low soy area
data.subset <- if(mask.soy.area) {
data.subset[data.subset$total_planted_area_km2 >= min_soy_area,]
}
# define the formula ------------------------------------------------------------------------------------------------------
# define the basic formula
formula.string <- paste(y.var, paste(c(x.vars, interaction.pairs), collapse = " + "), sep = " ~ ")
# check for time.handle
if (time.handle == "year.trend") {formula.string <- paste(formula.string, "year_index", sep = " + ")}
f <- as.formula(formula.string)
# do the model -------------------------------------------------------------------------------------------------------------
# evaluate model. note, simpler alternative: model <- lm(f, data = data.subset)
model <- eval(bquote(   lm(.(f), data = data.subset)   ))
return(model)
}
evaluate_model <- function(lm_results, test.x.vars, orig_data, title) {
print(title)
print(summary(lm_results))
plot(lm_results, which = c(1,2), main = title) # test error is homoscedastic, zero mean, normal
# test pearson's correlation for numeric variables used
df <- orig_data %>% subset(select = test.x.vars[test.x.vars %in% numeric.x.var.names])
test.corr <- cor(df)
print(c('predictor correlation matrix', title))
print(test.corr)
}
# Reduced model -------------------------------------------------------------------------------------------
test.y.var <- "plant_median"
# , "latitude", "longitude", "intensity", "soy_age", "region", "onset_historicalRange", "year_index"
test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age")
# note, doing x*y will create x + y + x:y, while x:y doesn't necessarily include x + y
test.interaction.vars <- c() #c("onset:latitude", "onset:longitude", "onset:intensity", "onset:soy_age", "onset:region")
test.time.handle <- "none"
test.spatial.fe.scale <- "none"
test.spatial.auto.model <- "none"
test.crop.intensity <- "none"
test.mask.soy.area <- TRUE
test1 <- do_lm(data = cell_tidy,
y.var = test.y.var,
x.vars = test.x.vars,
interaction.pairs = test.interaction.vars,
time.handle = test.time.handle,
spatial.fe.scale = test.spatial.fe.scale,
spatial.auto.model = test.spatial.auto.model,
crop.intensity = test.crop.intensity,
mask.soy.area = test.mask.soy.area)
print('reduced model')
evaluate_model(test1, test.x.vars, cell_tidy, "reduced model")
# 'Fuller' model -----------------------------------------------------------------------------------------
test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age")
test.interaction.vars <- c("onset:year")
test2 <- do_lm(data = cell_tidy,
y.var = test.y.var,
x.vars = test.x.vars,
interaction.pairs = test.interaction.vars,
time.handle = test.time.handle,
spatial.fe.scale = test.spatial.fe.scale,
spatial.auto.model = test.spatial.auto.model,
crop.intensity = test.crop.intensity,
mask.soy.area = test.mask.soy.area)
print('full model')
evaluate_model(test2, test.x.vars, cell_tidy, "full model")
anova(test1, test2)
# list of numeric x variable names, to be used in multicollinearity test
numeric.x.var.names <- c("onset", "latitude", "longitude", "onset_historicalRange", "year", "year_index")
# do linear model
# NEEDS year fixed effect, spatial fixed effect, FE vs ME, spatial autocorrelation handling
do_lm <- function(data, y.var, time.handle, spatial.fe.scale, spatial.auto.model, x.vars, interaction.pairs,
crop.intensity, mask.soy.area) {
# options:
# x.vars = vector of predictors, names of variables are in quotes
# crop.intensity = "none", "DC", "SC"
# time.handle = "none", "year.trend" (uses year_index as x var), "year.fe" (uses year as fixed or mixed effect)
# spatial.fe.scale = "none", "regions.4", "municipality", "grid.1deg", "geo.weighted"
# spatial.auto.model = "none", "spatial.lag", "spatial.error"
# interaction.pairs = vector of interactions as will be written in the lm formula, e.g. onset*latitude
# mask.soy.area = TRUE or FALSE, if TRUE take out rows with total soy area below min_soy_area
# subset the data  --------------------------------------------------------------------------------------------------------
# get only the desired cropping intensity
data.subset <- if(crop.intensity == "none") {
data
} else {
data[data$intensity == crop.intensity,]
}
# get rid of observations with low soy area
data.subset <- if(mask.soy.area) {
data.subset[data.subset$total_planted_area_km2 >= min_soy_area,]
}
# define the formula ------------------------------------------------------------------------------------------------------
# define the basic formula
formula.string <- paste(y.var, paste(c(x.vars, interaction.pairs), collapse = " + "), sep = " ~ ")
# check for time.handle
if (time.handle == "year.trend") {formula.string <- paste(formula.string, "year_index", sep = " + ")}
f <- as.formula(formula.string)
# do the model -------------------------------------------------------------------------------------------------------------
# evaluate model. note, simpler alternative: model <- lm(f, data = data.subset)
model <- eval(bquote(   lm(.(f), data = data.subset)   ))
return(model)
}
evaluate_model <- function(lm_results, test.x.vars, orig_data, title) {
print(title)
print(summary(lm_results))
plot(lm_results, which = c(1,2), main = title) # test error is homoscedastic, zero mean, normal
# test pearson's correlation for numeric variables used
df <- orig_data %>% subset(select = test.x.vars[test.x.vars %in% numeric.x.var.names])
test.corr <- cor(df)
print(c('predictor correlation matrix', title))
print(test.corr)
}
# Reduced model -------------------------------------------------------------------------------------------
test.y.var <- "plant_median"
# , "latitude", "longitude", "intensity", "soy_age", "region", "onset_historicalRange", "year_index"
test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age")
# note, doing x*y will create x + y + x:y, while x:y doesn't necessarily include x + y
test.interaction.vars <- c() #c("onset:latitude", "onset:longitude", "onset:intensity", "onset:soy_age", "onset:region")
test.time.handle <- "none"
test.spatial.fe.scale <- "none"
test.spatial.auto.model <- "none"
test.crop.intensity <- "none"
test.mask.soy.area <- TRUE
test1 <- do_lm(data = cell_tidy,
y.var = test.y.var,
x.vars = test.x.vars,
interaction.pairs = test.interaction.vars,
time.handle = test.time.handle,
spatial.fe.scale = test.spatial.fe.scale,
spatial.auto.model = test.spatial.auto.model,
crop.intensity = test.crop.intensity,
mask.soy.area = test.mask.soy.area)
print('reduced model')
evaluate_model(test1, test.x.vars, cell_tidy, "reduced model")
# 'Fuller' model -----------------------------------------------------------------------------------------
test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age")
test.interaction.vars <- c("onset:latitude")
test2 <- do_lm(data = cell_tidy,
y.var = test.y.var,
x.vars = test.x.vars,
interaction.pairs = test.interaction.vars,
time.handle = test.time.handle,
spatial.fe.scale = test.spatial.fe.scale,
spatial.auto.model = test.spatial.auto.model,
crop.intensity = test.crop.intensity,
mask.soy.area = test.mask.soy.area)
print('full model')
evaluate_model(test2, test.x.vars, cell_tidy, "full model")
anova(test1, test2)
# list of numeric x variable names, to be used in multicollinearity test
numeric.x.var.names <- c("onset", "latitude", "longitude", "onset_historicalRange", "year", "year_index")
# do linear model
# NEEDS year fixed effect, spatial fixed effect, FE vs ME, spatial autocorrelation handling
do_lm <- function(data, y.var, time.handle, spatial.fe.scale, spatial.auto.model, x.vars, interaction.pairs,
crop.intensity, mask.soy.area) {
# options:
# x.vars = vector of predictors, names of variables are in quotes
# crop.intensity = "none", "DC", "SC"
# time.handle = "none", "year.trend" (uses year_index as x var), "year.fe" (uses year as fixed or mixed effect)
# spatial.fe.scale = "none", "regions.4", "municipality", "grid.1deg", "geo.weighted"
# spatial.auto.model = "none", "spatial.lag", "spatial.error"
# interaction.pairs = vector of interactions as will be written in the lm formula, e.g. onset*latitude
# mask.soy.area = TRUE or FALSE, if TRUE take out rows with total soy area below min_soy_area
# subset the data  --------------------------------------------------------------------------------------------------------
# get only the desired cropping intensity
data.subset <- if(crop.intensity == "none") {
data
} else {
data[data$intensity == crop.intensity,]
}
# get rid of observations with low soy area
data.subset <- if(mask.soy.area) {
data.subset[data.subset$total_planted_area_km2 >= min_soy_area,]
}
# define the formula ------------------------------------------------------------------------------------------------------
# define the basic formula
formula.string <- paste(y.var, paste(c(x.vars, interaction.pairs), collapse = " + "), sep = " ~ ")
# check for time.handle
if (time.handle == "year.trend") {formula.string <- paste(formula.string, "year_index", sep = " + ")}
f <- as.formula(formula.string)
# do the model -------------------------------------------------------------------------------------------------------------
# evaluate model. note, simpler alternative: model <- lm(f, data = data.subset)
model <- eval(bquote(   lm(.(f), data = data.subset)   ))
return(model)
}
evaluate_model <- function(lm_results, test.x.vars, orig_data, title) {
print(title)
print(summary(lm_results))
plot(lm_results, which = c(1,2), main = title) # test error is homoscedastic, zero mean, normal
# test pearson's correlation for numeric variables used
df <- orig_data %>% subset(select = test.x.vars[test.x.vars %in% numeric.x.var.names])
test.corr <- cor(df)
print(c('predictor correlation matrix', title))
print(test.corr)
}
# Reduced model -------------------------------------------------------------------------------------------
test.y.var <- "plant_median"
# , "latitude", "longitude", "intensity", "soy_age", "region", "onset_historicalRange", "year_index"
test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age")
# note, doing x*y will create x + y + x:y, while x:y doesn't necessarily include x + y
test.interaction.vars <- c() #c("onset:latitude", "onset:longitude", "onset:intensity", "onset:soy_age", "onset:region")
test.time.handle <- "none"
test.spatial.fe.scale <- "none"
test.spatial.auto.model <- "none"
test.crop.intensity <- "none"
test.mask.soy.area <- TRUE
test1 <- do_lm(data = cell_tidy,
y.var = test.y.var,
x.vars = test.x.vars,
interaction.pairs = test.interaction.vars,
time.handle = test.time.handle,
spatial.fe.scale = test.spatial.fe.scale,
spatial.auto.model = test.spatial.auto.model,
crop.intensity = test.crop.intensity,
mask.soy.area = test.mask.soy.area)
print('reduced model')
evaluate_model(test1, test.x.vars, cell_tidy, "reduced model")
# 'Fuller' model -----------------------------------------------------------------------------------------
test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age")
test.interaction.vars <- c("onset:longitude")
test2 <- do_lm(data = cell_tidy,
y.var = test.y.var,
x.vars = test.x.vars,
interaction.pairs = test.interaction.vars,
time.handle = test.time.handle,
spatial.fe.scale = test.spatial.fe.scale,
spatial.auto.model = test.spatial.auto.model,
crop.intensity = test.crop.intensity,
mask.soy.area = test.mask.soy.area)
print('full model')
evaluate_model(test2, test.x.vars, cell_tidy, "full model")
anova(test1, test2)
# list of numeric x variable names, to be used in multicollinearity test
numeric.x.var.names <- c("onset", "latitude", "longitude", "onset_historicalRange", "year", "year_index")
# do linear model
# NEEDS year fixed effect, spatial fixed effect, FE vs ME, spatial autocorrelation handling
do_lm <- function(data, y.var, time.handle, spatial.fe.scale, spatial.auto.model, x.vars, interaction.pairs,
crop.intensity, mask.soy.area) {
# options:
# x.vars = vector of predictors, names of variables are in quotes
# crop.intensity = "none", "DC", "SC"
# time.handle = "none", "year.trend" (uses year_index as x var), "year.fe" (uses year as fixed or mixed effect)
# spatial.fe.scale = "none", "regions.4", "municipality", "grid.1deg", "geo.weighted"
# spatial.auto.model = "none", "spatial.lag", "spatial.error"
# interaction.pairs = vector of interactions as will be written in the lm formula, e.g. onset*latitude
# mask.soy.area = TRUE or FALSE, if TRUE take out rows with total soy area below min_soy_area
# subset the data  --------------------------------------------------------------------------------------------------------
# get only the desired cropping intensity
data.subset <- if(crop.intensity == "none") {
data
} else {
data[data$intensity == crop.intensity,]
}
# get rid of observations with low soy area
data.subset <- if(mask.soy.area) {
data.subset[data.subset$total_planted_area_km2 >= min_soy_area,]
}
# define the formula ------------------------------------------------------------------------------------------------------
# define the basic formula
formula.string <- paste(y.var, paste(c(x.vars, interaction.pairs), collapse = " + "), sep = " ~ ")
# check for time.handle
if (time.handle == "year.trend") {formula.string <- paste(formula.string, "year_index", sep = " + ")}
f <- as.formula(formula.string)
# do the model -------------------------------------------------------------------------------------------------------------
# evaluate model. note, simpler alternative: model <- lm(f, data = data.subset)
model <- eval(bquote(   lm(.(f), data = data.subset)   ))
return(model)
}
evaluate_model <- function(lm_results, test.x.vars, orig_data, title) {
print(title)
print(summary(lm_results))
plot(lm_results, which = c(1,2), main = title) # test error is homoscedastic, zero mean, normal
# test pearson's correlation for numeric variables used
df <- orig_data %>% subset(select = test.x.vars[test.x.vars %in% numeric.x.var.names])
test.corr <- cor(df)
print(c('predictor correlation matrix', title))
print(test.corr)
}
# Reduced model -------------------------------------------------------------------------------------------
test.y.var <- "plant_median"
# , "latitude", "longitude", "intensity", "soy_age", "region", "onset_historicalRange", "year_index"
test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age")
# note, doing x*y will create x + y + x:y, while x:y doesn't necessarily include x + y
test.interaction.vars <- c() #c("onset:latitude", "onset:longitude", "onset:intensity", "onset:soy_age", "onset:region")
test.time.handle <- "none"
test.spatial.fe.scale <- "none"
test.spatial.auto.model <- "none"
test.crop.intensity <- "none"
test.mask.soy.area <- TRUE
test1 <- do_lm(data = cell_tidy,
y.var = test.y.var,
x.vars = test.x.vars,
interaction.pairs = test.interaction.vars,
time.handle = test.time.handle,
spatial.fe.scale = test.spatial.fe.scale,
spatial.auto.model = test.spatial.auto.model,
crop.intensity = test.crop.intensity,
mask.soy.area = test.mask.soy.area)
print('reduced model')
evaluate_model(test1, test.x.vars, cell_tidy, "reduced model")
# 'Fuller' model -----------------------------------------------------------------------------------------
test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age")
test.interaction.vars <- c("onset:soy_age")
test2 <- do_lm(data = cell_tidy,
y.var = test.y.var,
x.vars = test.x.vars,
interaction.pairs = test.interaction.vars,
time.handle = test.time.handle,
spatial.fe.scale = test.spatial.fe.scale,
spatial.auto.model = test.spatial.auto.model,
crop.intensity = test.crop.intensity,
mask.soy.area = test.mask.soy.area)
print('full model')
evaluate_model(test2, test.x.vars, cell_tidy, "full model")
anova(test1, test2)
# list of numeric x variable names, to be used in multicollinearity test
numeric.x.var.names <- c("onset", "latitude", "longitude", "onset_historicalRange", "year", "year_index")
# do linear model
# NEEDS year fixed effect, spatial fixed effect, FE vs ME, spatial autocorrelation handling
do_lm <- function(data, y.var, time.handle, spatial.fe.scale, spatial.auto.model, x.vars, interaction.pairs,
crop.intensity, mask.soy.area) {
# options:
# x.vars = vector of predictors, names of variables are in quotes
# crop.intensity = "none", "DC", "SC"
# time.handle = "none", "year.trend" (uses year_index as x var), "year.fe" (uses year as fixed or mixed effect)
# spatial.fe.scale = "none", "regions.4", "municipality", "grid.1deg", "geo.weighted"
# spatial.auto.model = "none", "spatial.lag", "spatial.error"
# interaction.pairs = vector of interactions as will be written in the lm formula, e.g. onset*latitude
# mask.soy.area = TRUE or FALSE, if TRUE take out rows with total soy area below min_soy_area
# subset the data  --------------------------------------------------------------------------------------------------------
# get only the desired cropping intensity
data.subset <- if(crop.intensity == "none") {
data
} else {
data[data$intensity == crop.intensity,]
}
# get rid of observations with low soy area
data.subset <- if(mask.soy.area) {
data.subset[data.subset$total_planted_area_km2 >= min_soy_area,]
}
# define the formula ------------------------------------------------------------------------------------------------------
# define the basic formula
formula.string <- paste(y.var, paste(c(x.vars, interaction.pairs), collapse = " + "), sep = " ~ ")
# check for time.handle
if (time.handle == "year.trend") {formula.string <- paste(formula.string, "year_index", sep = " + ")}
f <- as.formula(formula.string)
# do the model -------------------------------------------------------------------------------------------------------------
# evaluate model. note, simpler alternative: model <- lm(f, data = data.subset)
model <- eval(bquote(   lm(.(f), data = data.subset)   ))
return(model)
}
evaluate_model <- function(lm_results, test.x.vars, orig_data, title) {
print(title)
print(summary(lm_results))
plot(lm_results, which = c(1,2), main = title) # test error is homoscedastic, zero mean, normal
# test pearson's correlation for numeric variables used
df <- orig_data %>% subset(select = test.x.vars[test.x.vars %in% numeric.x.var.names])
test.corr <- cor(df)
print(c('predictor correlation matrix', title))
print(test.corr)
}
# Reduced model -------------------------------------------------------------------------------------------
test.y.var <- "plant_median"
# , "latitude", "longitude", "intensity", "soy_age", "region", "onset_historicalRange", "year_index"
test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age")
# note, doing x*y will create x + y + x:y, while x:y doesn't necessarily include x + y
test.interaction.vars <- c() #c("onset:latitude", "onset:longitude", "onset:intensity", "onset:soy_age", "onset:region")
test.time.handle <- "none"
test.spatial.fe.scale <- "none"
test.spatial.auto.model <- "none"
test.crop.intensity <- "none"
test.mask.soy.area <- TRUE
test1 <- do_lm(data = cell_tidy,
y.var = test.y.var,
x.vars = test.x.vars,
interaction.pairs = test.interaction.vars,
time.handle = test.time.handle,
spatial.fe.scale = test.spatial.fe.scale,
spatial.auto.model = test.spatial.auto.model,
crop.intensity = test.crop.intensity,
mask.soy.area = test.mask.soy.area)
print('reduced model')
evaluate_model(test1, test.x.vars, cell_tidy, "reduced model")
# 'Fuller' model -----------------------------------------------------------------------------------------
test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age")
test.interaction.vars <- c("onset:region")
test2 <- do_lm(data = cell_tidy,
y.var = test.y.var,
x.vars = test.x.vars,
interaction.pairs = test.interaction.vars,
time.handle = test.time.handle,
spatial.fe.scale = test.spatial.fe.scale,
spatial.auto.model = test.spatial.auto.model,
crop.intensity = test.crop.intensity,
mask.soy.area = test.mask.soy.area)
print('full model')
evaluate_model(test2, test.x.vars, cell_tidy, "full model")
anova(test1, test2)

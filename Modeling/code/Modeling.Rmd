---
title: "Exploration"
output: html_document
---

## read data

```{r}

library(ggplot2)
library(tidyverse)
library(dplyr)
library(rgdal)
library(raster)
library(sf)
library(sp)

source('E:/R-code/Modeling/code/FCN_clean_csvs.R')

median_cell_raw <- read.csv('E:/R-code/Modeling/data/median_onset_cell_v2.csv')
percentile5_cell_raw <- read.csv('E:/R-code/Modeling/data/percentile5_onset_cell_v2.csv')
percentile95_cell_raw <- read.csv('E:/R-code/Modeling/data/percentile95_onset_cell_v2.csv')

median_muni_raw <- read.csv('E:/R-code/Modeling/data/median_muni_v2.csv')
percentile5_muni_raw <- read.csv('E:/R-code/Modeling/data/percentile5_muni_v2.csv')
percentile95_muni_raw <- read.csv('E:/R-code/Modeling/data/percentile95_muni_v2.csv')

median_CARpoly_raw <- read.csv('E:/R-code/Modeling/data/median_CARpoly_v2.csv')
percentile5_CARpoly_raw <- read.csv('E:/R-code/Modeling/data/percentile5_CARpoly_v2.csv')
percentile95_CARpoly_raw <- read.csv('E:/R-code/Modeling/data/percentile95_CARpoly_v2.csv')

grid_1deg <- readOGR(dsn = 'E:/R-code/Modeling/data/shp/grid_1deg', layer = 'grid_1deg')
munis <- readOGR(dsn = 'E:/R-code/Modeling/data/shp/munis', layer = 'munis_SHP')
crs(munis) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
  
```

## spatial join muni to CARpolys

```{r}

# rename columns of CARpoly data and combine into a single csv before spatial join
median_CARpoly_raw <- rename_cols_median_CARpoly(median_CARpoly_raw)
percentile5_CARpoly_raw <- rename_cols_percentile5_CARpoly(percentile5_CARpoly_raw)
percentile95_CARpoly_raw <- rename_cols_percentile95_CARpoly(percentile95_CARpoly_raw)
CARpoly_raw <- create_CARpoly_raw(median_CARpoly_raw, percentile5_CARpoly_raw, percentile95_CARpoly_raw)

CARpoly_raw <- join_CARpoly_to_muni(CARpoly_raw)

```

## constants

```{r}

min_soy_area <- 2 #km2. min area of total or SC/DC soy in cell, muni or property to be considered in model

```

## rename and delete the columns (only needed for median)

```{r}

# median cell
median_cell <- median_cell_raw %>% delete_cols_median_cell() %>%
                                    rename_cols_median_cell()
percentile5_cell <- percentile5_cell_raw %>% filter(year > 0)
percentile95_cell <- percentile95_cell_raw %>% filter(year > 0)

# median muni
median_muni <- median_muni_raw %>% rename_cols_median_muni()
percentile5_muni <- percentile5_muni_raw %>% filter(year > 0)
percentile95_muni <- percentile95_muni_raw %>% filter(year > 0)

```

## tidy the data and categorize the numeric variables

```{r}

# create tidy datasets
cell_tidy <- tidy_combine_cell(median_cell, percentile5_cell, percentile95_cell)
muni_tidy <- tidy_combine_muni(median_muni, percentile5_muni, percentile95_muni)
CARpoly_tidy <- tidy_CARpoly(CARpoly_raw)

# categorize numeric variables
cell_tidy <- categorize_vars_cell_tidy(cell_tidy)
cell_untidy <- categorize_vars_cell_untidy(median_cell)

muni_tidy <- categorize_vars_muni_tidy(muni_tidy)
muni_untidy <- categorize_vars_muni_untidy(median_muni)


CARpoly_tidy <- categorize_vars_CARpoly_tidy(CARpoly_tidy) %>% delete_cols_CARpoly_tidy()
CARpoly_untidy <- categorize_vars_CARpoly_untidy(CARpoly_raw) 
# change rename cols and delete unnecessary cols
CARpoly_untidy <- CARpoly_untidy %>% rename_cols_CARpoly_untidy() %>%
                                    delete_cols_CARpoly_untidy()
  

# categorize as new or old or neither in planted soy age (so far only have it for cell scale)
cell_tidy <- cell_tidy %>% cell_categorize_soy_age()
cell_untidy <- cell_untidy %>% cell_categorize_soy_age()

# add year_index
cell_tidy$year_index <- cell_tidy$year - 2003
cell_untidy$year_index <- cell_untidy$year - 2003
muni_tidy$year_index <- muni_tidy$year - 2003
muni_untidy$year_index <- muni_untidy$year - 2003
CARpoly_tidy$year_index <- CARpoly_tidy$year - 2003
CARpoly_untidy$year_index <- CARpoly_untidy$year - 2003

# choose munis that were planted in 2014 and 2004, merge them 
#munis_2014 <- muni_tidy[muni_tidy$year == "2014", c("total_planted_area_km2", "Muni_code")]
#munis_2004 <- muni_tidy[muni_tidy$Muni_code %in% munis_2014$Muni_code & 
#                          muni_tidy$year == "2004", c("total_planted_area_km2", "Muni_code")]
#munis_2014 <- munis_2014 %>% rename(area_2014 = total_planted_area_km2)
#munis_2004 <- munis_2004 %>% rename(area_2004 = total_planted_area_km2)
#munis_merged <- merge(munis_2014, munis_2004, by = "Muni_code") %>% unique()
#soy_age <- rep("neither", length(munis_merged$Muni_code))
```

## models for cell scale

```{r}
# list of numeric x variable names, to be used in multicollinearity test
numeric.x.var.names <- c("onset", "latitude", "longitude", "onset_historicalRange", "year", "year_index")

# do linear model
# NEEDS year fixed effect, spatial fixed effect, FE vs ME, spatial autocorrelation handling
do_lm <- function(data, y.var, time.handle, spatial.fe.scale, spatial.auto.model, x.vars, interaction.pairs, 
                  crop.intensity, mask.soy.area) {
  # options:
  # x.vars = vector of predictors, names of variables are in quotes
  # crop.intensity = "none", "DC", "SC"
  # time.handle = "none", "year.trend" (uses year_index as x var), "year.fe" (uses year as fixed or mixed effect)
  # spatial.fe.scale = "none", "regions.4", "municipality", "grid.1deg", "geo.weighted"
  # spatial.auto.model = "none", "spatial.lag", "spatial.error"
  # interaction.pairs = vector of interactions as will be written in the lm formula, e.g. onset*latitude
  # mask.soy.area = TRUE or FALSE, if TRUE take out rows with total soy area below min_soy_area
  
  # subset the data  --------------------------------------------------------------------------------------------------------
  # get only the desired cropping intensity
  data.subset <- if(crop.intensity == "none") {
    data
  } else {
    data[data$intensity == crop.intensity,]
  }
  
  # get rid of observations with low soy area
  data.subset <- if(mask.soy.area) {
    data.subset[data.subset$total_planted_area_km2 >= min_soy_area,]
  }
  
  # define the formula ------------------------------------------------------------------------------------------------------
  # define the basic formula
  formula.string <- paste(y.var, paste(c(x.vars, interaction.pairs), collapse = " + "), sep = " ~ ")
  
  # check for time.handle
  if (time.handle == "year.trend") {formula.string <- paste(formula.string, "year_index", sep = " + ")}
  
  f <- as.formula(formula.string)

  # do the model -------------------------------------------------------------------------------------------------------------
  # evaluate model. note, simpler alternative: model <- lm(f, data = data.subset)
  model <- eval(bquote(   lm(.(f), data = data.subset)   ))
  
  return(model)
}

evaluate_model <- function(lm_results, test.x.vars, orig_data, title) {
  
  print(title)
  print(summary(lm_results))
  plot(lm_results, which = c(1,2), main = title) # test error is homoscedastic, zero mean, normal
  
  # test pearson's correlation for numeric variables used
  df <- orig_data %>% subset(select = test.x.vars[test.x.vars %in% numeric.x.var.names])
  test.corr <- cor(df)
  
  print(c('predictor correlation matrix', title))
  print(test.corr)
}

# Reduced model -------------------------------------------------------------------------------------------
test.y.var <- "plant_median"
# , "latitude", "longitude", "intensity", "soy_age", "region", "onset_historicalRange", "year_index"
test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age")
# note, doing x*y will create x + y + x:y, while x:y doesn't necessarily include x + y
test.interaction.vars <- c() #c("onset:latitude", "onset:longitude", "onset:intensity", "onset:soy_age", "onset:region")
test.time.handle <- "none"
test.spatial.fe.scale <- "none"
test.spatial.auto.model <- "none"
test.crop.intensity <- "none"
test.mask.soy.area <- TRUE
test1 <- do_lm(data = cell_tidy, 
              y.var = test.y.var, 
              x.vars = test.x.vars, 
              interaction.pairs = test.interaction.vars,
              time.handle = test.time.handle, 
              spatial.fe.scale = test.spatial.fe.scale, 
              spatial.auto.model = test.spatial.auto.model,  
              crop.intensity = test.crop.intensity,
              mask.soy.area = test.mask.soy.area)

print('reduced model')
evaluate_model(test1, test.x.vars, cell_tidy, "reduced model")

# 'Fuller' model -----------------------------------------------------------------------------------------

test.x.vars <- c("onset", "intensity", "year", "region", "latitude", "soy_age")
test.interaction.vars <- c("onset:region")
test2 <- do_lm(data = cell_tidy, 
              y.var = test.y.var, 
              x.vars = test.x.vars, 
              interaction.pairs = test.interaction.vars,
              time.handle = test.time.handle, 
              spatial.fe.scale = test.spatial.fe.scale, 
              spatial.auto.model = test.spatial.auto.model,  
              crop.intensity = test.crop.intensity,
              mask.soy.area = test.mask.soy.area)

print('full model')
evaluate_model(test2, test.x.vars, cell_tidy, "full model")

anova(test1, test2)
```

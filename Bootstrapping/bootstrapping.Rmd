---
title: "Bootstrapping"
output: html_document
---

## Read and clean pixel level range errors from Planet validation data

```{r}

library(MASS)

p1_errors <- read.csv('p1_error_toBootstrap.csv')
h1_errors <- read.csv('h1_error_toBootstrap.csv')

p1_y <- p1_errors$p1_lowerBoundError - p1_errors$p1_upperBoundError
h1_y <- h1_errors$h1_lowerBoundError - h1_errors$h1_upperBoundError


# fit to normal distribution and plot
fit_p1_lowerBound <- fitdistr(p1_errors$p1_lowerBoundError, "normal")
para_p1_lowerBound <- fit_p1_lowerBound$estimate
hist(p1_errors$p1_lowerBoundError, prob = TRUE, main = "p1 lower bound error", xlab = 'error [days]')
curve(dnorm(x, para_p1_lowerBound[1], para_p1_lowerBound[2]), col = 2, add = TRUE)

fit_p1_upperBound <- fitdistr(p1_errors$p1_upperBoundError, "normal")
para_p1_upperBound <- fit_p1_upperBound$estimate
hist(p1_errors$p1_upperBoundError, prob = TRUE, main = "p1 upper bound error", xlab = 'error [days]')
curve(dnorm(x, para_p1_upperBound[1], para_p1_upperBound[2]), col = 2, add = TRUE)

fit_h1_lowerBound <- fitdistr(h1_errors$h1_lowerBoundError, "normal")
para_h1_lowerBound <- fit_h1_lowerBound$estimate
hist(h1_errors$h1_lowerBoundError, prob = TRUE, main = "h1 lower bound error", xlab = 'error [days]')
curve(dnorm(x, para_h1_lowerBound[1], para_h1_lowerBound[2]), col = 2, add = TRUE)

fit_h1_upperBound <- fitdistr(h1_errors$h1_upperBoundError, "normal")
para_h1_upperBound <- fit_h1_upperBound$estimate
hist(h1_errors$h1_upperBoundError, prob = TRUE, main = "h1 upper bound error", xlab = 'error [days]')
curve(dnorm(x, para_h1_upperBound[1], para_h1_upperBound[2]), col = 2, add = TRUE)

fit_h1_y <- fitdistr(h1_y, "normal")
para_h1_y <- fit_h1_y$estimate
hist(h1_y, prob = TRUE, main = "h1 y", xlab = 'error [days]')
curve(dnorm(x, para_h1_y[1], para_h1_y[2]), col = 2, add = TRUE)

fit_p1_y <- fitdistr(p1_y, "normal")
para_p1_y <- fit_p1_y$estimate
hist(p1_y, prob = TRUE, main = "p1 y", xlab = 'error [days]')
curve(dnorm(x, para_p1_y[1], para_p1_y[2]), col = 2, add = TRUE)

```

## Create land use cases

```{r}

# set up 50km x 50km cells, initialize with 10,000 'pixels'

prop_agri = 0.09 # proportion of the cell that is agriculture. in 2004, it was 0.07; in 2014, it was 0.11. calculated by GEE file LandCover/MapbiomasAgriCover

prop_SC = 15410/(15410 + 71581 + 3636) # proportion of training pts that are SC in 2007
prop_DC = 71581/(15410 + 71581 + 3636) # proportion of training pts that are DC in 2007
prop_nonsoy = 3636/(15410 + 71581 + 3636) # proportion of training pts that are nonsoy in 2007

total_pixels = 50000*50000/(500*500) # total number of 500m pixels in 50km cell

# calculate the number of each 
agri_pixels = total_pixels*prop_agri
SC_pixels = round(total_pixels*prop_agri*prop_SC)
DC_pixels = round(total_pixels*prop_agri*prop_DC)
nonsoy_pixels = round(total_pixels*prop_agri*prop_nonsoy)

# actual case (this is 'known' based on the )
actual_case = c(rep(0, SC_pixels), rep(1, DC_pixels), rep(2, nonsoy_pixels))

# generate a classified case

# start by calculating the indices of the falsely classified pixels, this can be used to index actual_case
wrong_SC <- sample(1:SC_pixels, 0.41*SC_pixels, replace=F)
wrong_DC <- sample((SC_pixels+1):(SC_pixels + DC_pixels), 0.14*DC_pixels, replace=F)
wrong_nonsoy <- sample((SC_pixels+DC_pixels+1):length(actual_case), 0.34*nonsoy_pixels, replace=F)

# calculate proportion of wrongly calculated pixels that are 'actually' which class
frac_wrong_SC_actual_DC = 301/(301+9)
frac_wrong_DC_actual_SC = 548/(548 + 128)
frac_wrong_nonsoy_actual_SC = 3/(3 + 53)

# of the falsely classified pixels, calculate the indices of the 'actual' classes
wrong_SC_actual_DC = sample(wrong_SC, frac_wrong_SC_actual_DC*length(wrong_SC), replace=F)
wrong_SC_actual_nonsoy = unique(wrong_SC[! wrong_SC %in%  wrong_SC_actual_DC])
wrong_DC_actual_SC = sample(wrong_DC, frac_wrong_DC_actual_SC*length(wrong_DC), replace = F)
wrong_DC_actual_nonsoy = unique(wrong_DC[! wrong_DC %in%  wrong_DC_actual_SC])
wrong_nonsoy_actual_SC = sample(wrong_nonsoy, frac_wrong_nonsoy_actual_SC*length(wrong_nonsoy), replace = F)
wrong_nonsoy_actual_DC = unique(wrong_nonsoy[! wrong_nonsoy %in%  wrong_nonsoy_actual_SC])

# for above, generate Two nested random choices: randomly choose the pixels whose land cover is 'falsely classified'; proportion is 100 - 59 % for SC (301/total wrongly predicted SC pts become DC; 9/total wrongly predicted SC pts become nonsoy agri); 100 - 86 % of DC must change (548/total wrongly predicted DC pts becomes SC, 128/total wrongly predicted DC pts becomes nonsoy agri); 100 - 66% of nonsoy agri must change (3/total wrongly predicted nonsoy pts becomes SC; 53/total wrongly predicted nonsoy pts becomes DC). total DC pts comes from confusion matrix.

# create one 'predicted/erroneous' set of pixels


```

## Sample the pixel level error distribution

```{r}
mean_plant = 0 # center on 0 since we're doing differences for land cover error anyway
sd_plant = 10

mean_harvest = 0
sd_harvest = 5

set.seed(124)
pixel_plant <- rnorm(agri_pixels, mean_plant, sd_plant)
pixel_harvest <-rnorm(agri_pixels, mean_harvest, sd_harvest)

```

## Calculate median plant and harvest for the cell

```{r}

# for actual case
median_plant_SC = median(pixel_plant[actual_case == 0])
median_plant_DC = median(pixel_plant[actual_case == 1])
median_plant_nonsoy = median(pixel_plant[actual_case == 2])
median_plant_soy = median(pixel_plant[actual_case < 2])

# for actual case

```

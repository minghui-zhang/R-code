for (a_index in 1:num_as) {
for (y_index in 1:num_ys) {
a <- as[a_index]
y <- ys[y_index]
prob_a <- p_a(a, plant_or_harv)
prob_y <- p_y(y, plant_or_harv)
H_a <- Heaviside(x, a = a)
H_b <- Heaviside(x, a = (y + a))
result <- prob_a*prob_y*(H_a - H_b)/y
result_matrix[a_index, y_index] <- result
}
}
return(sum(result_matrix))
}
# given value of x, return the value of the double integral
calc_integral_2 <- function(x, plant_or_harv, as, bs) {
# initialize matrix to hold the argument of the integrals
num_as <- length(as)
num_bs <- length(bs)
result_matrix <- matrix(nrow = num_as, ncol = num_ys)
for (a_index in 1:num_as) {
for (b_index in 1:num_bs) {
a <- as[a_index]
b <- bs[b_index]
prob_a <- p_a(a, plant_or_harv)
prob_b <- p_b(b, plant_or_harv)
H_a <- Heaviside(x, a = a)
H_b <- Heaviside(x, a = b)
result <- prob_a*prob_y*(H_a - H_b)/(b - a)
result_matrix[a_index, b_index] <- result
}
}
return(sum(result_matrix))
}
# calculate p(x)
prob_x_plant <- sapply(xs, calc_integral_2, plant_or_harv = 'plant', as = as, bs = ys)
library(fBasics) # for Heaviside fcn
library(dplyr)
# vectors of a and y over which to integrate, and vector of x over which to calculate p(x)
as <- seq(-100, 100, 10)
bs <- seq(-100, 100, 10)
ys <- seq(0.1, 100, 10)
xs <- seq(-50, 200, 10)
# given value of a (upper bound), find p(a)
p_a <- function(a, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_upperBound[1]
fitted_sd <- para_p1_upperBound[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_upperBound[1]
fitted_sd <- para_h1_upperBound[2]
}
return(pnorm(a, mean = fitted_mean, sd = fitted_sd))
}
# given value of b (lower bound), find p(b)
p_b <- function(b, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_lowerBound[1]
fitted_sd <- para_p1_lowerBound[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_lowerBound[1]
fitted_sd <- para_h1_lowerBound[2]
}
return(pnorm(b, mean = fitted_mean, sd = fitted_sd))
}
# given value of y (b - a or lower bound - upper bound), find p(y)
p_y <- function(y, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_y[1]
fitted_sd <- para_p1_y[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_y[1]
fitted_sd <- para_h1_y[2]
}
return(pnorm(y, mean = fitted_mean, sd = fitted_sd))
}
# given value of x, return the value of the double integral
calc_integral <- function(x, plant_or_harv, as, ys) {
# initialize matrix to hold the argument of the integrals
num_as <- length(as)
num_ys <- length(ys)
result_matrix <- matrix(nrow = num_as, ncol = num_ys)
for (a_index in 1:num_as) {
for (y_index in 1:num_ys) {
a <- as[a_index]
y <- ys[y_index]
prob_a <- p_a(a, plant_or_harv)
prob_y <- p_y(y, plant_or_harv)
H_a <- Heaviside(x, a = a)
H_b <- Heaviside(x, a = (y + a))
result <- prob_a*prob_y*(H_a - H_b)/y
result_matrix[a_index, y_index] <- result
}
}
return(sum(result_matrix))
}
# given value of x, return the value of the double integral
calc_integral_2 <- function(x, plant_or_harv, as, bs) {
# initialize matrix to hold the argument of the integrals
num_as <- length(as)
num_bs <- length(bs)
result_matrix <- matrix(nrow = num_as, ncol = num_bs)
for (a_index in 1:num_as) {
for (b_index in 1:num_bs) {
a <- as[a_index]
b <- bs[b_index]
prob_a <- p_a(a, plant_or_harv)
prob_b <- p_b(b, plant_or_harv)
H_a <- Heaviside(x, a = a)
H_b <- Heaviside(x, a = b)
result <- prob_a*prob_y*(H_a - H_b)/(b - a)
result_matrix[a_index, b_index] <- result
}
}
return(sum(result_matrix))
}
# calculate p(x)
prob_x_plant <- sapply(xs, calc_integral_2, plant_or_harv = 'plant', as = as, bs = ys)
library(fBasics) # for Heaviside fcn
library(dplyr)
# vectors of a and y over which to integrate, and vector of x over which to calculate p(x)
as <- seq(-100, 100, 10)
bs <- seq(-100, 100, 10)
ys <- seq(0.1, 100, 10)
xs <- seq(-50, 200, 10)
# given value of a (upper bound), find p(a)
p_a <- function(a, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_upperBound[1]
fitted_sd <- para_p1_upperBound[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_upperBound[1]
fitted_sd <- para_h1_upperBound[2]
}
return(pnorm(a, mean = fitted_mean, sd = fitted_sd))
}
# given value of b (lower bound), find p(b)
p_b <- function(b, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_lowerBound[1]
fitted_sd <- para_p1_lowerBound[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_lowerBound[1]
fitted_sd <- para_h1_lowerBound[2]
}
return(pnorm(b, mean = fitted_mean, sd = fitted_sd))
}
# given value of y (b - a or lower bound - upper bound), find p(y)
p_y <- function(y, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_y[1]
fitted_sd <- para_p1_y[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_y[1]
fitted_sd <- para_h1_y[2]
}
return(pnorm(y, mean = fitted_mean, sd = fitted_sd))
}
# given value of x, return the value of the double integral
calc_integral <- function(x, plant_or_harv, as, ys) {
# initialize matrix to hold the argument of the integrals
num_as <- length(as)
num_ys <- length(ys)
result_matrix <- matrix(nrow = num_as, ncol = num_ys)
for (a_index in 1:num_as) {
for (y_index in 1:num_ys) {
a <- as[a_index]
y <- ys[y_index]
prob_a <- p_a(a, plant_or_harv)
prob_y <- p_y(y, plant_or_harv)
H_a <- Heaviside(x, a = a)
H_b <- Heaviside(x, a = (y + a))
result <- prob_a*prob_y*(H_a - H_b)/y
result_matrix[a_index, y_index] <- result
}
}
return(sum(result_matrix))
}
# given value of x, return the value of the double integral
calc_integral_2 <- function(x, plant_or_harv, as, bs) {
# initialize matrix to hold the argument of the integrals
num_as <- length(as)
num_bs <- length(bs)
result_matrix <- matrix(nrow = num_as, ncol = num_bs)
for (a_index in 1:num_as) {
for (b_index in 1:num_bs) {
a <- as[a_index]
b <- bs[b_index]
prob_a <- p_a(a, plant_or_harv)
prob_b <- p_b(b, plant_or_harv)
H_a <- Heaviside(x, a = a)
H_b <- Heaviside(x, a = b)
result <- prob_a*prob_b*(H_a - H_b)/(b - a)
result_matrix[a_index, b_index] <- result
}
}
return(sum(result_matrix))
}
# calculate p(x)
prob_x_plant <- sapply(xs, calc_integral_2, plant_or_harv = 'plant', as = as, bs = ys)
prob_x_harv <- sapply(xs, calc_integral_2, plant_or_harv = 'harvest', as = as, bs = ys)
# fit p(x) to its own distribution (mean and sd) using nls()
plant_error_data <- data.frame(error=xs, density=prob_x_plant)
res <- nls( density ~ k*exp(-1/2*(error-mu)^2/sigma^2), start=c(mu=70,sigma=30,k=1) , data = plant_error_data)
plant_error_params <- summary(res)$parameters[,"Estimate"]
plant_error_mean <- plant_error_params[1]
plant_error_sd <- plant_error_params[2]
plant_error_scale <- plant_error_params[3]
plot(xs, prob_x_plant, main = 'p(error) for planting', xlab = 'error', ylab = 'density')
plot(function(x) plant_error_scale*exp(-1/2*(x-plant_error_mean)^2/plant_error_sd^2),col=2,add=T,xlim=range(plant_error_data$error))
harvest_error_data <- data.frame(error=xs, density=prob_x_harv)
res <- nls( density ~ k*exp(-1/2*(error-mu)^2/sigma^2), start=c(mu=70,sigma=30,k=1) , data = harvest_error_data)
library(fBasics) # for Heaviside fcn
library(dplyr)
# vectors of a and y over which to integrate, and vector of x over which to calculate p(x)
as <- seq(-100, 100, 10)
bs <- seq(-100, 100, 10)
ys <- seq(0.1, 100, 10)
xs <- seq(-50, 200, 10)
# given value of a (upper bound), find p(a)
p_a <- function(a, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_upperBound[1]
fitted_sd <- para_p1_upperBound[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_upperBound[1]
fitted_sd <- para_h1_upperBound[2]
}
return(pnorm(a, mean = fitted_mean, sd = fitted_sd))
}
# given value of b (lower bound), find p(b)
p_b <- function(b, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_lowerBound[1]
fitted_sd <- para_p1_lowerBound[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_lowerBound[1]
fitted_sd <- para_h1_lowerBound[2]
}
return(pnorm(b, mean = fitted_mean, sd = fitted_sd))
}
# given value of y (b - a or lower bound - upper bound), find p(y)
p_y <- function(y, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_y[1]
fitted_sd <- para_p1_y[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_y[1]
fitted_sd <- para_h1_y[2]
}
return(pnorm(y, mean = fitted_mean, sd = fitted_sd))
}
# given value of x, return the value of the double integral
calc_integral <- function(x, plant_or_harv, as, ys) {
# initialize matrix to hold the argument of the integrals
num_as <- length(as)
num_ys <- length(ys)
result_matrix <- matrix(nrow = num_as, ncol = num_ys)
for (a_index in 1:num_as) {
for (y_index in 1:num_ys) {
a <- as[a_index]
y <- ys[y_index]
prob_a <- p_a(a, plant_or_harv)
prob_y <- p_y(y, plant_or_harv)
H_a <- Heaviside(x, a = a)
H_b <- Heaviside(x, a = (y + a))
result <- prob_a*prob_y*(H_a - H_b)/y
result_matrix[a_index, y_index] <- result
}
}
return(sum(result_matrix))
}
# given value of x, return the value of the double integral
calc_integral_2 <- function(x, plant_or_harv, as, bs) {
# initialize matrix to hold the argument of the integrals
num_as <- length(as)
num_bs <- length(bs)
result_matrix <- matrix(nrow = num_as, ncol = num_bs)
for (a_index in 1:num_as) {
for (b_index in 1:num_bs) {
a <- as[a_index]
b <- bs[b_index]
prob_a <- p_a(a, plant_or_harv)
prob_b <- p_b(b, plant_or_harv)
H_a <- Heaviside(x, a = a)
H_b <- Heaviside(x, a = b)
result <- prob_a*prob_b*(H_a - H_b)/(b - a)
result_matrix[a_index, b_index] <- result
}
}
return(sum(result_matrix))
}
# calculate p(x) - use either calc_integral or calc_integral_2
prob_x_plant <- sapply(xs, calc_integral_2, plant_or_harv = 'plant', as = as, bs = bs)
prob_x_harv <- sapply(xs, calc_integral_2, plant_or_harv = 'harvest', as = as, bs = bs)
#prob_x_plant <- sapply(xs, calc_integral, plant_or_harv = 'plant', as = as, ys = ys)
#prob_x_harv <- sapply(xs, calc_integral, plant_or_harv = 'harvest', as = as, ys = ys)
# fit p(x) to its own distribution (mean and sd) using nls()
plant_error_data <- data.frame(error=xs, density=prob_x_plant)
res <- nls( density ~ k*exp(-1/2*(error-mu)^2/sigma^2), start=c(mu=70,sigma=30,k=1) , data = plant_error_data)
?nls
library(fBasics) # for Heaviside fcn
library(dplyr)
# vectors of a and y over which to integrate, and vector of x over which to calculate p(x)
as <- seq(-100, 100, 10)
bs <- seq(-100, 100, 10)
ys <- seq(0.1, 100, 10)
xs <- seq(-50, 200, 10)
# given value of a (upper bound), find p(a)
p_a <- function(a, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_upperBound[1]
fitted_sd <- para_p1_upperBound[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_upperBound[1]
fitted_sd <- para_h1_upperBound[2]
}
return(pnorm(a, mean = fitted_mean, sd = fitted_sd))
}
# given value of b (lower bound), find p(b)
p_b <- function(b, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_lowerBound[1]
fitted_sd <- para_p1_lowerBound[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_lowerBound[1]
fitted_sd <- para_h1_lowerBound[2]
}
return(pnorm(b, mean = fitted_mean, sd = fitted_sd))
}
# given value of y (b - a or lower bound - upper bound), find p(y)
p_y <- function(y, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_y[1]
fitted_sd <- para_p1_y[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_y[1]
fitted_sd <- para_h1_y[2]
}
return(pnorm(y, mean = fitted_mean, sd = fitted_sd))
}
# given value of x, return the value of the double integral
calc_integral <- function(x, plant_or_harv, as, ys) {
# initialize matrix to hold the argument of the integrals
num_as <- length(as)
num_ys <- length(ys)
result_matrix <- matrix(nrow = num_as, ncol = num_ys)
for (a_index in 1:num_as) {
for (y_index in 1:num_ys) {
a <- as[a_index]
y <- ys[y_index]
prob_a <- p_a(a, plant_or_harv)
prob_y <- p_y(y, plant_or_harv)
H_a <- Heaviside(x, a = a)
H_b <- Heaviside(x, a = (y + a))
result <- prob_a*prob_y*(H_a - H_b)/y
result_matrix[a_index, y_index] <- result
}
}
return(sum(result_matrix))
}
# given value of x, return the value of the double integral
calc_integral_2 <- function(x, plant_or_harv, as, bs) {
# initialize matrix to hold the argument of the integrals
num_as <- length(as)
num_bs <- length(bs)
result_matrix <- matrix(nrow = num_as, ncol = num_bs)
for (a_index in 1:num_as) {
for (b_index in 1:num_bs) {
a <- as[a_index]
b <- bs[b_index]
prob_a <- p_a(a, plant_or_harv)
prob_b <- p_b(b, plant_or_harv)
H_a <- Heaviside(x, a = a)
H_b <- Heaviside(x, a = b)
result <- prob_a*prob_b*(H_a - H_b)/(b - a)
result_matrix[a_index, b_index] <- result
}
}
return(sum(result_matrix))
}
# calculate p(x) - use either calc_integral or calc_integral_2
prob_x_plant <- sapply(xs, calc_integral_2, plant_or_harv = 'plant', as = as, bs = bs)
prob_x_harv <- sapply(xs, calc_integral_2, plant_or_harv = 'harvest', as = as, bs = bs)
#prob_x_plant <- sapply(xs, calc_integral, plant_or_harv = 'plant', as = as, ys = ys)
#prob_x_harv <- sapply(xs, calc_integral, plant_or_harv = 'harvest', as = as, ys = ys)
# fit p(x) to its own distribution (mean and sd) using nls()
plant_error_data <- data.frame(error=xs, density=prob_x_plant)
res <- nls( density ~ k*exp(-1/2*(error-mu)^2/sigma^2), start=c(mu=60,sigma=30,k=1) , data = plant_error_data,  control = nls.control(maxiter = 500))
harvest_error_data <- data.frame(error=xs, density=prob_x_harv)
res <- nls( density ~ k*exp(-1/2*(error-mu)^2/sigma^2), start=c(mu=60,sigma=30,k=1) , data = harvest_error_data,  control = nls.control(maxiter = 500))
library(fBasics) # for Heaviside fcn
library(dplyr)
# vectors of a and y over which to integrate, and vector of x over which to calculate p(x)
as <- seq(-100, 100, 10)
bs <- seq(-100, 100, 10)
ys <- seq(0.1, 100, 10)
xs <- seq(-50, 200, 10)
# given value of a (upper bound), find p(a)
p_a <- function(a, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_upperBound[1]
fitted_sd <- para_p1_upperBound[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_upperBound[1]
fitted_sd <- para_h1_upperBound[2]
}
return(pnorm(a, mean = fitted_mean, sd = fitted_sd))
}
# given value of b (lower bound), find p(b)
p_b <- function(b, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_lowerBound[1]
fitted_sd <- para_p1_lowerBound[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_lowerBound[1]
fitted_sd <- para_h1_lowerBound[2]
}
return(pnorm(b, mean = fitted_mean, sd = fitted_sd))
}
# given value of y (b - a or lower bound - upper bound), find p(y)
p_y <- function(y, plant_or_harv) {
if (plant_or_harv == 'plant') {
fitted_mean <- para_p1_y[1]
fitted_sd <- para_p1_y[2]
}
else if (plant_or_harv == 'harvest') {
fitted_mean <- para_h1_y[1]
fitted_sd <- para_h1_y[2]
}
return(pnorm(y, mean = fitted_mean, sd = fitted_sd))
}
# given value of x, return the value of the double integral
calc_integral <- function(x, plant_or_harv, as, ys) {
# initialize matrix to hold the argument of the integrals
num_as <- length(as)
num_ys <- length(ys)
result_matrix <- matrix(nrow = num_as, ncol = num_ys)
for (a_index in 1:num_as) {
for (y_index in 1:num_ys) {
a <- as[a_index]
y <- ys[y_index]
prob_a <- p_a(a, plant_or_harv)
prob_y <- p_y(y, plant_or_harv)
H_a <- Heaviside(x, a = a)
H_b <- Heaviside(x, a = (y + a))
result <- prob_a*prob_y*(H_a - H_b)/y
result_matrix[a_index, y_index] <- result
}
}
return(sum(result_matrix))
}
# given value of x, return the value of the double integral
calc_integral_2 <- function(x, plant_or_harv, as, bs) {
# initialize matrix to hold the argument of the integrals
num_as <- length(as)
num_bs <- length(bs)
result_matrix <- matrix(nrow = num_as, ncol = num_bs)
for (a_index in 1:num_as) {
for (b_index in 1:num_bs) {
a <- as[a_index]
b <- bs[b_index]
prob_a <- p_a(a, plant_or_harv)
prob_b <- p_b(b, plant_or_harv)
H_a <- Heaviside(x, a = a)
H_b <- Heaviside(x, a = b)
result <- prob_a*prob_b*(H_a - H_b)/(b - a)
result_matrix[a_index, b_index] <- result
}
}
return(sum(result_matrix))
}
# calculate p(x) - use either calc_integral or calc_integral_2
#prob_x_plant <- sapply(xs, calc_integral_2, plant_or_harv = 'plant', as = as, bs = bs)
#prob_x_harv <- sapply(xs, calc_integral_2, plant_or_harv = 'harvest', as = as, bs = bs)
prob_x_plant <- sapply(xs, calc_integral, plant_or_harv = 'plant', as = as, ys = ys)
prob_x_harv <- sapply(xs, calc_integral, plant_or_harv = 'harvest', as = as, ys = ys)
# fit p(x) to its own distribution (mean and sd) using nls()
plant_error_data <- data.frame(error=xs, density=prob_x_plant)
res <- nls( density ~ k*exp(-1/2*(error-mu)^2/sigma^2), start=c(mu=60,sigma=30,k=1) , data = plant_error_data,  control = nls.control(maxiter = 500))
plant_error_params <- summary(res)$parameters[,"Estimate"]
plant_error_mean <- plant_error_params[1]
plant_error_sd <- plant_error_params[2]
plant_error_scale <- plant_error_params[3]
plot(xs, prob_x_plant, main = 'p(error) for planting', xlab = 'error', ylab = 'density')
plot(function(x) plant_error_scale*exp(-1/2*(x-plant_error_mean)^2/plant_error_sd^2),col=2,add=T,xlim=range(plant_error_data$error))
harvest_error_data <- data.frame(error=xs, density=prob_x_harv)
res <- nls( density ~ k*exp(-1/2*(error-mu)^2/sigma^2), start=c(mu=60,sigma=30,k=1) , data = harvest_error_data,  control = nls.control(maxiter = 500))
harvest_error_params <- summary(res)$parameters[,"Estimate"]
harvest_error_mean <- harvest_error_params[1]
harvest_error_sd <- harvest_error_params[2]
harvest_error_scale <- harvest_error_params[3]
plot(xs, prob_x_harv, main = 'p(error) for harvest', xlab = 'error', ylab = 'density')
plot(function(x) harvest_error_scale*exp(-1/2*(x-harvest_error_mean)^2/harvest_error_sd^2),col=2,add=T,xlim=range(plant_error_data$error))
print(c('plant error mean', plant_error_mean))
print(c('plant error sd', plant_error_sd))
print(c('harvest error mean', harvest_error_mean))
print(c('harvest error sd', harvest_error_sd))
